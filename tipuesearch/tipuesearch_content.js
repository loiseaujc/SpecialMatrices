var tipuesearch = {"pages":[{"title":" SpecialMatrices ","text":"SpecialMatrices Warning This API documentation for the SpecialMatrices pacakge is a work in progress.\n   It is build from the source code in the main branch and does not track the current development in dev or any other branches.\n   If you use another branch, please refer to the in-code documentation.\n   Use the navigation bar at the top of the screen to browse modules , procedures , source files , etc.\n   The listings near the bootom of the page are incomplete. Developer Info Jean-Christophe Loiseau","tags":"home","loc":"index.html"},{"title":"Circulant – SpecialMatrices ","text":"type, public :: Circulant Base type to define a Circulant matrix of size [n x n] with elements\ngiven by the vector Constructor public        interface Circulant This interface provides methods to construct Circulant matrices.\nGiven a vector ,\nthe associated Circulant matrix is the following [n x n] matrix Syntax integer , parameter :: n = 100 real ( dp ) :: c ( n ) type ( Circulant ) :: A call random_number ( c ) A = Circulant ( c ) Note Only double precision is currently supported for this matrix type. private pure module function construct(c) result(A) Construct a Circulant matrix from the rank-1 array c . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: c (:) Generating vector. Return Value type( Circulant ) Corresponding Circulant matrix.","tags":"","loc":"type/circulant.html"},{"title":"Bidiagonal – SpecialMatrices ","text":"type, public :: Bidiagonal Base type used to define a Bidiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dv (size n ) and ev (size n-1 ). Constructor public        interface Bidiagonal This interface provides different methods to construct a Bidiagonal matrix. Only the non-zero elements of are\nstored, i.e. if is lower-bidiagonal or if is upper-bidiagonal. Warning By default, the matrix is lower-bidiagonal. To create an upper-\nbidiagonal, set A%which = \"U\" . Syntax Construct a Bidiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Bidiagonal ) :: A A = Bidiagonal ( n ) Construct a Bidiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( Bidiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Bidiagonal ( dv , ev ) Construct a Bidiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( Bidiagonal ) :: A A = Bidiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dv, ev, which) result(A) Construct a Bidiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) Bidiagonal elements of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-diagonal. Return Value type( Bidiagonal ) Bidiagonal matrix. private pure module function construct_constant(d, e, n, which) result(A) Construct a Bidiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: e Bidiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-bidiagonal. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix. private pure module function initialize(n) result(A) Construct a Bidiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix.","tags":"","loc":"type/bidiagonal.html"},{"title":"Toeplitz – SpecialMatrices ","text":"type, public :: Toeplitz Base type to define a Toeplitz matrix of size [m x n]. The first\ncolumn is given by the vector vc while the first row is given by vr . Constructor public        interface Toeplitz This interface provides methods to construct Toeplitz matrices.\nGiven a vector vc specifying the first column of the matrix and a\nvector vr specifying its first row, the associated Toeplitz matrix is the following matrix Syntax integer , parameter :: m = 100 , n = 200 real ( dp ) :: vc ( n ), vr ( n ) type ( Toeplitz ) :: A call random_number ( vc ) ; call random_number ( vr ) A = Toeplitz ( vc , vr ) Warning The element is read from the first entry of the vector vc . The first entry of vr is not referenced. Note Only double precision is currently supported for this matrix type. private pure module function construct(vc, vr) result(A) Construct a Toeplitz matrix from the rank-1 arrays vc and vr . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vc (:) First column of the matrix. real(kind=dp), intent(in) :: vr (:) First row of the matrix. Return Value type( Toeplitz ) Corresponding Toeplitz matrix.","tags":"","loc":"type/toeplitz.html"},{"title":"SymTridiagonal – SpecialMatrices ","text":"type, public :: SymTridiagonal Base type used to define a SymTridiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dv (size n ) and ev (size n-1 ). Constructor public        interface SymTridiagonal This interface provides different methods to construct a SymTridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a SymTridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( SymTridiagonal ) :: A A = SymTridiagonal ( n ) Construct a SymTridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( SymTridiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Tridiagonal ( dv , ev ) Construct a SymTridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( SymTridiagonal ) :: A A = SymTridiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. Note If is known to be symmetric positive definite, it can be\nconstructed as A = SymTridiagonal(dv, ev, ifposdef=.true.) :w private pure module function construct(dv, ev, isposdef) result(A) Construct a SymTridiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) SymTridiagonal elements of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function construct_constant(d, e, n, isposdef) result(A) Construct a SymTridiagonal matrix with constant diagonal\nelements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: e SymTridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a SymTridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix.","tags":"","loc":"type/symtridiagonal.html"},{"title":"Poisson2D – SpecialMatrices ","text":"type, public :: Poisson2D Base type used to define a Poisson2D matrix on a rectangular domain\ndiscretized with nx and ny points in each direction and\ncorresponding grid spacings dx and dy . Constructor public        interface Poisson2D Constructor for generating a Poisson2D matrix. The matrix corresponds\nto the standard second-order accurate finite-difference approximation\nof the Laplace operator with homogeneous Dirichlet boundary conditions. Syntax Construct the finite-difference approximation of the Laplace operator\n   on the rectangular domain using 128 points in the horizontal direction and 256 in the\n   vertical one. type ( Poisson2D ) :: A integer , parameter :: nx = 128 , ny = 256 real ( dp ), parameter :: Lx = 1.0_dp , Ly = 2.0_dp A = Poisson2D ( nx , ny , Lx , Ly ) Note Only doube precision is currently supported for this matrix type. Note Note that Lx and Ly are optional. If not specified, they default\nto 1.0_dp . private pure module function initialize(nx, ny, Lx, Ly) result(A) Utility function to construct a Poisson2D matrix. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: nx Number of grid points in each direction. integer(kind=ilp), intent(in) :: ny Number of grid points in each direction. real(kind=dp), intent(in), optional :: Lx Physical extent of each dimension. real(kind=dp), intent(in), optional :: Ly Physical extent of each dimension. Return Value type( Poisson2D ) Corresponding Poisson2D matrix.","tags":"","loc":"type/poisson2d.html"},{"title":"Strang – SpecialMatrices ","text":"type, public :: Strang Base type used to define the Strang matrix. Components Type Visibility Attributes Name Initial integer(kind=ilp), public :: n Dimension of the matrix. Constructor public        interface Strang Constructor for generating the Strang matrix of size n . The\nmatrix corresponds to the standard 3-point finite-difference\napproximation of the 1D Laplace operator with unit grid-spacing\n( ) and homogeneous Dirichlet boundary conditions.\nIt reads Syntax Construct a Strang matrix of size 100. integer , parameter :: n = 100 type ( Strang ) :: S S = Strang ( n ) Note Only double precision is currently supported for this matrix type. private pure module function initialize(n) result(A) Construct the Strang matrix of size n . Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Strang ) Strang matrix of size n .","tags":"","loc":"type/strang.html"},{"title":"Diagonal – SpecialMatrices ","text":"type, public :: Diagonal Base type used to define a Diagonal matrix of size [n x n] with diagonal elements given by the rank-1 array dv . Constructor public        interface Diagonal This interface provides different methods to construct a Diagonal matrix. Only the diagonal elements of are being stored, i.e. Syntax Construct a Diagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Diagonal ) :: A A = Diagonal ( n ) Construct a Diagonal matrix from a vector. integer , parameter :: n = 100 real ( dp ), allocatable :: dv (:) type ( Diagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; A = Diagonal ( dv ) Construct a Diagonal matrix with constant diagonal element. integer , parameter :: n = 100 real ( dp ), parameter :: d = 2.0_dp type ( Diagonal ) :: A A = Diagonal ( d , n ) Construct a Diagonal matrix from a standard rank-2 array. integer , parameter :: n = 100 real ( dp ) :: B ( n , n ) type ( Diagonal ) :: A call random_number ( B ); A = Diagonal ( B ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dv) result(A) Utility function to construct a Diagonal matrix from a rank-1\narray. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Diagonal elements of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function construct_constant(d, n) result(A) Utility function to construct a Diagonal matrix with constant\ndiagonal element. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Constant diagonal element of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private module function dense_to_diag(A) result(B) Utility function to construct a Diagonal matrix from a rank-2\narray. The resulting matrix is constructed from the diagonal\nelement of the input matrix, even if the latter is not diagonal. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Dense matrix from which to construct the Diagonal one. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function initialize(n) result(A) Utility function to construct a Diagonal matrix filled with\nzeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix.","tags":"","loc":"type/diagonal.html"},{"title":"Tridiagonal – SpecialMatrices ","text":"type, public :: Tridiagonal Base type used to define a Tridiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dl (size n ), dv (size n-1 ) and du (size n-1 ). Constructor public        interface Tridiagonal This interface provides different methods to construct a Tridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a Tridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Tridiagonal ) :: A A = Tridiagonal ( n ) Construct a Tridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: dl (:), dv (:), du (:) type ( Tridiagonal ) :: A integer :: i dl = [( i , i = 1 , n - 1 )]; dv = [( 2 * i , i = 1 , n )]; du = [( 3 * i , i = 1 , n )] A = Tridiagonal ( dl , dv , du ) Construct a Tridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: a = 1.0_dp , b = 1.0_dp , c = 2.0_dp type ( Tridiagonal ) :: A A = Tridiagonal ( a , b , c , n ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dl, dv, du) result(A) Construct a Tridiagonal matrix from the rank-1 arrays dl , dv and du . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du (:) Tridiagonal elements of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function construct_constant(dl, dv, du, n) result(A) Construct a Tridiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du Tridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a Tridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix.","tags":"","loc":"type/tridiagonal.html"},{"title":"Circulant – SpecialMatrices","text":"public interface Circulant This interface provides methods to construct Circulant matrices.\nGiven a vector ,\nthe associated Circulant matrix is the following [n x n] matrix Syntax integer , parameter :: n = 100 real ( dp ) :: c ( n ) type ( Circulant ) :: A call random_number ( c ) A = Circulant ( c ) Note Only double precision is currently supported for this matrix type. Functions private pure module function construct(c) result(A) Construct a Circulant matrix from the rank-1 array c . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: c (:) Generating vector. Return Value type( Circulant ) Corresponding Circulant matrix.","tags":"","loc":"interface/circulant.html"},{"title":"dense – SpecialMatrices","text":"public interface dense Convert a Circulant matrix to its dense representation. Syntax B = dense ( A ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private module function dense_rdp(A) result(B) Utility function to convert a Circulant matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense.html"},{"title":"eig – SpecialMatrices","text":"public interface eig This interface overloads the eig interface from stdlib_linalg to\ncompute the eigenvalues and eigenvectors of a real-valued matrix whose type is Circulant . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Circulant .\n         It is an intent(in) argument. lambda :   Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note Eigenvalues of a circulant matrix can be efficiently computed using\nthe Fast Fourier Transform of the generating vector c . Likewise,\nits eigenvectors are simply the corresponding Fourier modes. Subroutines private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors.","tags":"","loc":"interface/eig.html"},{"title":"eigvals – SpecialMatrices","text":"public interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose\ntype is Circulant . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Circulant type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Note Eigenvalues of a circulant matrix can be efficiently computed using\nthe Fast Fourier Transform of the generating vector c . Functions private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvals.html"},{"title":"inv – SpecialMatrices","text":"public interface inv Functions private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Circulant matrix.\nIf A is circulant, its inverse also is circulant. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value type( Circulant ) Inverse of A .","tags":"","loc":"interface/inv.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Circulant matrix, both for matrix-vector and matrix-matrix products.\nFor a matrix-matrix product , only the matrix has to be a Circulant matrix. Both and need to be\nstandard Fortran rank-2 arrays. All the underlying functions are\ndefined as pure . Syntax y = matmul ( A , x ) Functions private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Circulant matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Circulant matrix A .\nBoth X and Y are rank-2 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:,:) Input matrix. Return Value real(kind=dp), allocatable, (:,:) Output matrix.","tags":"","loc":"interface/matmul.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Circulant ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Circulant matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Circulant ), intent(in) :: A Return Value type( Circulant )","tags":"","loc":"interface/operator(ASTERISK).html"},{"title":"shape – SpecialMatrices","text":"public interface shape Utility function to return the shape of a Circulant matrix. Functions private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape.html"},{"title":"size – SpecialMatrices","text":"public interface size Utility function to return the size of a Circulant matrix along\na given dimension. Functions private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Circulant matrix along a\ngiven dimension. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Circulant matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Note Linear systems characterized by a circulant matrix can be solved\nefficiently in operations using the\nFast Fourier Transform algorithm available via fftpack . Functions private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system , where A is Circulant and B is a rank-2 array. The solution matrix X has the same\ndimension and kind as the right-hand side matrix B . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is Circulant and b a standard rank-1 array. The solution vector x has the same\ndimension and kind as the right-hand side vector b . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector.","tags":"","loc":"interface/solve.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a Circulant matrix . Syntax call svd ( A , s , u , vt ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional) :   Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                     Its size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. Note Singular values and singular vectors of a Circulant matrix can be\nefficiently computed based on the Fast Fourier transform. Subroutines private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Circulant matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Functions private module function svdvals_rdp(A) result(s) Compute the singular values of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation of a Circulant matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Circulant .\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value type( Circulant ) Transpose of the matrix.","tags":"","loc":"interface/transpose.html"},{"title":"Bidiagonal – SpecialMatrices","text":"public interface Bidiagonal This interface provides different methods to construct a Bidiagonal matrix. Only the non-zero elements of are\nstored, i.e. if is lower-bidiagonal or if is upper-bidiagonal. Warning By default, the matrix is lower-bidiagonal. To create an upper-\nbidiagonal, set A%which = \"U\" . Syntax Construct a Bidiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Bidiagonal ) :: A A = Bidiagonal ( n ) Construct a Bidiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( Bidiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Bidiagonal ( dv , ev ) Construct a Bidiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( Bidiagonal ) :: A A = Bidiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. Functions private pure module function construct(dv, ev, which) result(A) Construct a Bidiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) Bidiagonal elements of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-diagonal. Return Value type( Bidiagonal ) Bidiagonal matrix. private pure module function construct_constant(d, e, n, which) result(A) Construct a Bidiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: e Bidiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-bidiagonal. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix. private pure module function initialize(n) result(A) Construct a Bidiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix.","tags":"","loc":"interface/bidiagonal.html"},{"title":"dense – SpecialMatrices","text":"public interface dense This interface provides methods to convert a Bidiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private module function dense_rdp(A) result(B) Utility function to convert a Bidiagonal matrix to a\nrank-2 array. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense~2.html"},{"title":"det – SpecialMatrices","text":"public interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Bidiagonal . Syntax d = det ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. Functions private pure module function det_rdp(A) result(d) Compute the determinant of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix.","tags":"","loc":"interface/det.html"},{"title":"eig – SpecialMatrices","text":"public interface eig This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Bidiagonal . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Bidiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No specialized eigensolvers for generic Bidiagonal matrices exist\nin LAPACK. This routine thus falls back to wrapping the eig procedure from stdlib_linalg which uses *geev under the hood. Subroutines private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors.","tags":"","loc":"interface/eig~2.html"},{"title":"eigvals – SpecialMatrices","text":"public interface eigvals This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Bidiagonal . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Bidiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Functions private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvals~2.html"},{"title":"inv – SpecialMatrices","text":"public interface inv Functions private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A .","tags":"","loc":"interface/inv~2.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Bidiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Bidiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) Functions private module function spmv(A, x) result(y) Compute the matrix-vector product for a Bidiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in), target :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Bidiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors.","tags":"","loc":"interface/matmul~2.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Bidiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Bidiagonal ), intent(in) :: A Return Value type( Bidiagonal )","tags":"","loc":"interface/operator(ASTERISK)~2.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Functions private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~2.html"},{"title":"size – SpecialMatrices","text":"public interface size Functions private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Bidiagonal matrix along\na given dimension. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size~2.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Bidiagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Functions private pure module function solve_multi_rhs(A, b) result(x) Solve the linear system where is of type Bidiagonal and B a standard rank-2 array. The solution matrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is of type Bidiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, target, (:) Solution vector.","tags":"","loc":"interface/solve~2.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Bidiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional) :   Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                     Its size should be [n, n] . It is an intent(out) argument. vt (optional):   Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows.\n                     Its size should be [n, n] . It is an intent(out) argument. Subroutines private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd~2.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Bidiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Functions private module function svdvals_rdp(A) result(s) Compute the singular values of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals~2.html"},{"title":"trace – SpecialMatrices","text":"public interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Bidiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. Functions private pure module function trace_rdp(A) result(tr) Compute the trace of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix.","tags":"","loc":"interface/trace.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose of a Bidiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value type( Bidiagonal ) Transpose of the matrix.","tags":"","loc":"interface/transpose~2.html"},{"title":"Circulant – SpecialMatrices","text":"public interface Circulant Utility function to embed an m x n Toeplitz matrix into an\n(m+n) x (m+n) Circulant matrix. Functions private pure module function Toeplitz2Circulant(T) result(C) Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: T Return Value type( Circulant )","tags":"","loc":"interface/circulant~2.html"},{"title":"Toeplitz – SpecialMatrices","text":"public interface Toeplitz This interface provides methods to construct Toeplitz matrices.\nGiven a vector vc specifying the first column of the matrix and a\nvector vr specifying its first row, the associated Toeplitz matrix is the following matrix Syntax integer , parameter :: m = 100 , n = 200 real ( dp ) :: vc ( n ), vr ( n ) type ( Toeplitz ) :: A call random_number ( vc ) ; call random_number ( vr ) A = Toeplitz ( vc , vr ) Warning The element is read from the first entry of the vector vc . The first entry of vr is not referenced. Note Only double precision is currently supported for this matrix type. Functions private pure module function construct(vc, vr) result(A) Construct a Toeplitz matrix from the rank-1 arrays vc and vr . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vc (:) First column of the matrix. real(kind=dp), intent(in) :: vr (:) First row of the matrix. Return Value type( Toeplitz ) Corresponding Toeplitz matrix.","tags":"","loc":"interface/toeplitz.html"},{"title":"dense – SpecialMatrices","text":"public interface dense Convert a Toeplitz matrix to a standard rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private pure module function dense_rdp(A) result(B) Utility function to convert a Toeplitz matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense~3.html"},{"title":"eig – SpecialMatrices","text":"public interface eig This interface overloads the eig interface from stdlib_linalg to\ncompute the eigenvalues and eigenvectors of a real-valued matrix whose type is Toeplitz . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Toeplitz .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order.\n               It is an intent(out) argument. left (optional) : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No analytic expression exist for the eigendecomposition of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function eig from stdlib_linalg is used. Subroutines private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors.","tags":"","loc":"interface/eig~3.html"},{"title":"eigvals – SpecialMatrices","text":"public interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose\ntype is Toeplitz . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Toeplitz type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Note No analytic expression exist for the eigenvalues of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function eigvals from stdlib_linalg is used. Functions private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvals~3.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Toeplitz matrix, both for matrix-vector and matrix-matrix products.\nFor a matrix-matrix product , only the matrix has to be a Toeplitz matrix. Both and need to be\nstandard Fortran rank-2 arrays. All the underlying functions are\ndefined as pure . Syntax y = matmul ( A , x ) Note Matrix-vector products for Toeplitz matrices can be efficiently\ncomputed by embedding the Toeplitz matrix into a Circulant matrix\nof size [m+n x m+n] and using the Fast Fourier Transform provided\nby fftpack . Functions private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Toeplitz matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Toeplitz matrix A .\nBoth X and Y are rank-2 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:,:) Input matrix. Return Value real(kind=dp), allocatable, (:,:) Output matrix.","tags":"","loc":"interface/matmul~3.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Toeplitz ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Toeplitz matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Toeplitz ), intent(in) :: A Return Value type( Toeplitz )","tags":"","loc":"interface/operator(ASTERISK)~3.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Utility function to return the size of a Toeplitz matrix. Functions private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~3.html"},{"title":"size – SpecialMatrices","text":"public interface size Utility function to return the size of Toeplitz matrix along a\ngiven dimension. Functions private pure module function size_rdp(A, dim) result(arr_size) Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size~3.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Toeplitz matrix. It also enables to solve a linear system with multiple\nright-hand sides. Syntax To solve a system with being of type Toeplitz : x = solve ( A , b ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Note Under the hood, a gmres solver is being used along with a\nCirculant preconditioner. By design, gmres is run until a\nrelative tolerance of is reached. Functions private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system , where A is Toeplitz and B is a rank-2 array. The solution matrix X has the same dimension\nand kind as the right-hand side matrix B . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is Toeplitz and b a standard rank-1 array. The solution vector x has the same\ndimension and kind as the right-hand side vector b . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector.","tags":"","loc":"interface/solve~3.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a Toeplitz matrix . Syntax call svd ( A , s , u , vt ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] . It is an intent(out) argument. Note No analytic expression exist for the singular value of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function svdvals from stdlib_linalg is used. Subroutines private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd~3.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Toeplitz matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Note No analytic expression exist for the singular values of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function svdvals from stdlib_linalg is used. Functions private module function svdvals_rdp(A) result(s) Compute the singular values of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals~3.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation of a Toeplitz matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value type( Toeplitz ) Transpose of the matrix.","tags":"","loc":"interface/transpose~3.html"},{"title":"SymTridiagonal – SpecialMatrices","text":"public interface SymTridiagonal This interface provides different methods to construct a SymTridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a SymTridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( SymTridiagonal ) :: A A = SymTridiagonal ( n ) Construct a SymTridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( SymTridiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Tridiagonal ( dv , ev ) Construct a SymTridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( SymTridiagonal ) :: A A = SymTridiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. Note If is known to be symmetric positive definite, it can be\nconstructed as A = SymTridiagonal(dv, ev, ifposdef=.true.) :w Functions private pure module function construct(dv, ev, isposdef) result(A) Construct a SymTridiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) SymTridiagonal elements of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function construct_constant(d, e, n, isposdef) result(A) Construct a SymTridiagonal matrix with constant diagonal\nelements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: e SymTridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a SymTridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix.","tags":"","loc":"interface/symtridiagonal.html"},{"title":"dense – SpecialMatrices","text":"public interface dense This interface provides methods to convert a SymTridiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private module function dense_rdp(A) result(B) Convert a SymTridiagonal matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense~4.html"},{"title":"det – SpecialMatrices","text":"public interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type SymTridiagonal . Syntax d = det ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. Functions private pure module function det_rdp(A) result(d) Compute the determinant of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix.","tags":"","loc":"interface/det~2.html"},{"title":"eigh – SpecialMatrices","text":"public interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a matrix whose\ntype is SymTridiagonal . Syntax call eigh ( A , lambda [, vectors ]) Arguments A :  Matrix of SymTridiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors (optional)  :  Rank-2 array of the same kind as A returning the eigenvectors of A .\n                           It is an intent(out) argument. Subroutines private module subroutine eigh_rdp(A, lambda, vectors) Compute the eigenvalues and eigenvectors of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), optional, allocatable, target :: vectors (:,:) Eigenvectors.","tags":"","loc":"interface/eigh.html"},{"title":"eigvalsh – SpecialMatrices","text":"public interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a matrix whose\ntype is SymTridiagonal . Syntax lambda = eigvalsh ( A ) Arguments A : real -valued matrix of SymTridiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Functions private module function eigvalsh_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvalsh.html"},{"title":"inv – SpecialMatrices","text":"public interface inv Functions private pure module function inv_rdp(A) result(B) Compute the inverse of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A .","tags":"","loc":"interface/inv~3.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a SymTridiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a SymTridiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) Functions private module function spmv(A, x) result(y) Compute the matrix-vector product for a SymTridiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a SymTridiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors.","tags":"","loc":"interface/matmul~4.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Scalar multiplication with a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( SymTridiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Scalar multiplication with a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( SymTridiagonal ), intent(in) :: A Return Value type( SymTridiagonal )","tags":"","loc":"interface/operator(ASTERISK)~4.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Functions private pure module function shape_rdp(A) result(arr_shape) Return the shape of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~4.html"},{"title":"size – SpecialMatrices","text":"public interface size Functions private pure module function size_rdp(A, dim) result(arr_size) Return the size of SymTridiagonal matrix along a given\ndimension. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size~4.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a SymTridiagonal matrix. It also enables to solve a linear system\nwith multiple right-hand sides. Syntax x = solve ( A , b [, refine ]) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. refine (optional) : Logical switch to enable solution refinement. x :  Solution of the linear system.\n         It has the same type and shape as b . Functions private module function solve_multi_rhs(A, b, refine) result(x) Solve the linear system where is of type SymTridiagonal and B a standard rank-2 array. The solution\nmatrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement of the solution is used or not. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Solve the linear system where is of type SymTridiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement of the solution is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector.","tags":"","loc":"interface/solve~4.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a SymTridiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. Subroutines private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional, allocatable :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional, allocatable :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd~4.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a SymTridiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Functions private module function svdvals_rdp(A) result(s) Compute the singular values of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals~4.html"},{"title":"trace – SpecialMatrices","text":"public interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type SymTridiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. Functions private pure module function trace_rdp(A) result(tr) Compute the trace of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix.","tags":"","loc":"interface/trace~2.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a SymTridiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Compute the transpose of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value type( SymTridiagonal ) Transpose of the matrix.","tags":"","loc":"interface/transpose~4.html"},{"title":"Poisson2D – SpecialMatrices","text":"public interface Poisson2D Constructor for generating a Poisson2D matrix. The matrix corresponds\nto the standard second-order accurate finite-difference approximation\nof the Laplace operator with homogeneous Dirichlet boundary conditions. Syntax Construct the finite-difference approximation of the Laplace operator\n   on the rectangular domain using 128 points in the horizontal direction and 256 in the\n   vertical one. type ( Poisson2D ) :: A integer , parameter :: nx = 128 , ny = 256 real ( dp ), parameter :: Lx = 1.0_dp , Ly = 2.0_dp A = Poisson2D ( nx , ny , Lx , Ly ) Note Only doube precision is currently supported for this matrix type. Note Note that Lx and Ly are optional. If not specified, they default\nto 1.0_dp . Functions private pure module function initialize(nx, ny, Lx, Ly) result(A) Utility function to construct a Poisson2D matrix. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: nx Number of grid points in each direction. integer(kind=ilp), intent(in) :: ny Number of grid points in each direction. real(kind=dp), intent(in), optional :: Lx Physical extent of each dimension. real(kind=dp), intent(in), optional :: Ly Physical extent of each dimension. Return Value type( Poisson2D ) Corresponding Poisson2D matrix.","tags":"","loc":"interface/poisson2d.html"},{"title":"dense – SpecialMatrices","text":"public interface dense Cnvert a matrix of type Poisson2D to its dense representation as a\nstandard rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. B :  Rank-2 real array corresponding to the dense representation\n         of A . Functions private pure module function dense_rdp(A) result(B) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Dense representation.","tags":"","loc":"interface/dense~5.html"},{"title":"eigh – SpecialMatrices","text":"public interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of the Poisson2D matrix . Syntax call eigh ( A , lambda , vectors ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. lambda : Rank-1 real array returning the eigenvalues of A in\n            increasing order. It is an intent(out) argument. vectors :   Rank-2 real array returning the eigenvectors of A .\n               It is an intent(out) argument. Note Both the eigenvalues and eigenvectors of the Poisson2D matrix are\nknown analytically and can thus be constructed efficiently. Subroutines private module subroutine eigh_rdp(A, lambda, vectors) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable, target :: lambda (:) Eigenvalues. real(kind=dp), intent(out), allocatable :: vectors (:,:)","tags":"","loc":"interface/eigh~2.html"},{"title":"eigvalsh – SpecialMatrices","text":"public interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of the Poisson2D matrix . Syntax lambda = eigvalsh ( A ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. Note The eigenvalues of the Poisson2D matrix are known analytically\nand can thus be computed efficiently. Functions private module function eigvalsh_rdp(A) result(lambda) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, target, (:) Eigenvalues.","tags":"","loc":"interface/eigvalsh~2.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Poisson2D matrixn, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Poisson2D matrix. Both and are\nstandard Fortran rank-2 arrays. Syntax y = matmul ( A , x ) Functions private module function spmv(A, x) result(y) Compute the matrix-vector product for a Poisson2D matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), allocatable, target, (:) Output vector. private module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Poisson2D matrix . and are rank-2 arrays of appropriate size with the same kind as . Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target, contiguous :: x (:,:) Input vectors. Return Value real(kind=dp), allocatable, target, (:,:) Output vectors.","tags":"","loc":"interface/matmul~5.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Utility function to return the shape a Poisson2D matrix . Functions private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of the Poisson2D matrix. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~5.html"},{"title":"size – SpecialMatrices","text":"public interface size Utility function to return the size of a Poisson2D matrix along a given dimension. Functions private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of a Poisson2D matrix along a given dimension. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Corresponding size.","tags":"","loc":"interface/size~5.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a system where is a Poisson2D matrix.\nIt also enables to solve a linear system with multiple right-hand\nsides. Syntax x = solve ( A , b ) Arguments A :  Matrix of type Poisson2D . It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . Note It uses a fast Poisson solver leveraging the discrete sine\ntransform provided by fftpack . Only homogeneous Dirichlet boundary\nconditions are handled by default. If non-homogeneous Dirichlet\nboundary conditions need to be used, they can be implemented by\nmodifiying the right-hand side vector. Neuman-type boundary\nconditions are not supported at all. Functions private pure module function solve_multi_rhs(A, b) result(x) Solve the linear system using a fast Poisson solver. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system using a fast Poisson solver. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, target, (:) Solution vector.","tags":"","loc":"interface/solve~5.html"},{"title":"say_hello – SpecialMatrices","text":"public  subroutine say_hello() Arguments None Source Code subroutine say_hello print * , \"Hello, SpecialMatrices!\" end subroutine say_hello","tags":"","loc":"proc/say_hello.html"},{"title":"Strang – SpecialMatrices","text":"public interface Strang Constructor for generating the Strang matrix of size n . The\nmatrix corresponds to the standard 3-point finite-difference\napproximation of the 1D Laplace operator with unit grid-spacing\n( ) and homogeneous Dirichlet boundary conditions.\nIt reads Syntax Construct a Strang matrix of size 100. integer , parameter :: n = 100 type ( Strang ) :: S S = Strang ( n ) Note Only double precision is currently supported for this matrix type. Functions private pure module function initialize(n) result(A) Construct the Strang matrix of size n . Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Strang ) Strang matrix of size n .","tags":"","loc":"interface/strang.html"},{"title":"dense – SpecialMatrices","text":"public interface dense Convert a matrix of type Strang to its dense representation as a\nstandard rank-2 array Syntax B = dense ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. B :  Rank-2 array representation fo the matrix . Functions private pure module function dense_rdp(A) result(B) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Dense representation.","tags":"","loc":"interface/dense~6.html"},{"title":"det – SpecialMatrices","text":"public interface det This interface overloads the det interface from stdlib_linalg to compute the determinant where is of type Strang . Syntax d = det ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. d :  Determinant of the matrix. Functions private pure module function det_rdp(A) result(d) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix.","tags":"","loc":"interface/det~3.html"},{"title":"eigh – SpecialMatrices","text":"public interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a Strang matrix. Syntax call eigh ( A , lambda , vectors ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors :  Rank-2 real array of size [n x n] returning the\n               eigenvectors of A . It is an intent(out) argument. Note Eigenvalues and eigenvectors of the Strang matrix are known\nanalytically and can thus be constructed very efficiently. Subroutines private pure module subroutine eigh_rdp(A, lambda, vectors) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), allocatable :: vectors (:,:) Eigenvectors.","tags":"","loc":"interface/eigh~3.html"},{"title":"eigvalsh – SpecialMatrices","text":"public interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a Strang matrix. Note that these\neigenvalues are known analytically. Syntax lambda = eigvalsh ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. Functions private pure module function eigvalsh_rdp(A) result(lambda) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvalsh~3.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for the Strang matrix, both for matrix-vector and matrix-matrix products.\nFor matrix-matrix product , only can be a Strang matrix. Both and are standard rank-2 arrays. All\nunderlying functions are defined as pure . Syntax y = matmul ( A , x ) Functions private pure module function spmv(A, x) result(y) Driver for the matrix-vector product. Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Driver for the matrix-matrix product. Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vector. Return Value real(kind=dp), allocatable, (:,:) Output vector.","tags":"","loc":"interface/matmul~6.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Utility function returning the shape of a Strang matrix . Functions private pure module function shape_rdp(A) result(arr_shape) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~6.html"},{"title":"size – SpecialMatrices","text":"public interface size Utility function returning the size of a Strang matrix along a given dimension. Functions private pure module function size_rdp(A, dim) result(arr_size) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in) :: dim Queried dimension. Return Value integer(kind=ilp) Corresponding size.","tags":"","loc":"interface/size~6.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a system where is a Strang matrix.\nIt also enables to solve a linear system with multiple right-hand\nsides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Strang type. It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . Functions private module function solve_multi_rhs(A, b, refine) result(x) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector.","tags":"","loc":"interface/solve~6.html"},{"title":"trace – SpecialMatrices","text":"public interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Strang . Strang tr = trace ( A ) Arguments A :  Matrix of Strang type. It is an intent(in) argument. tr :  Trace of the matrix. Functions private pure module function trace_rdp(A) result(tr) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix.","tags":"","loc":"interface/trace~3.html"},{"title":"Diagonal – SpecialMatrices","text":"public interface Diagonal This interface provides different methods to construct a Diagonal matrix. Only the diagonal elements of are being stored, i.e. Syntax Construct a Diagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Diagonal ) :: A A = Diagonal ( n ) Construct a Diagonal matrix from a vector. integer , parameter :: n = 100 real ( dp ), allocatable :: dv (:) type ( Diagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; A = Diagonal ( dv ) Construct a Diagonal matrix with constant diagonal element. integer , parameter :: n = 100 real ( dp ), parameter :: d = 2.0_dp type ( Diagonal ) :: A A = Diagonal ( d , n ) Construct a Diagonal matrix from a standard rank-2 array. integer , parameter :: n = 100 real ( dp ) :: B ( n , n ) type ( Diagonal ) :: A call random_number ( B ); A = Diagonal ( B ) Note Only double precision is currently supported for this matrix type. Functions private pure module function construct(dv) result(A) Utility function to construct a Diagonal matrix from a rank-1\narray. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Diagonal elements of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function construct_constant(d, n) result(A) Utility function to construct a Diagonal matrix with constant\ndiagonal element. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Constant diagonal element of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private module function dense_to_diag(A) result(B) Utility function to construct a Diagonal matrix from a rank-2\narray. The resulting matrix is constructed from the diagonal\nelement of the input matrix, even if the latter is not diagonal. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Dense matrix from which to construct the Diagonal one. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function initialize(n) result(A) Utility function to construct a Diagonal matrix filled with\nzeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix.","tags":"","loc":"interface/diagonal.html"},{"title":"dense – SpecialMatrices","text":"public interface dense This interface provides methods to convert a Diagonal matrix to a\nregular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private module function dense_rdp(A) result(B) Convert a Diagonal matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense~7.html"},{"title":"det – SpecialMatrices","text":"public interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Diagonal . Syntax d = det ( A ) Arguments A :  Matrix of Diagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. Functions private pure module function det_rdp(A) result(d) Compute the determinant of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix.","tags":"","loc":"interface/det~4.html"},{"title":"eigh – SpecialMatrices","text":"public interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Diagonal . Syntax call eigh ( A , lambda [, vectors ]) Arguments A : real -valued matrix of Diagonal .\n               It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors (optional)  :  Rank-2 array of the same kind as A returning the eigenvectors of A . It is\n                           an intent(out) argument. Subroutines private module subroutine eigh_rdp(A, lambda, vectors) Utility function to compute the eigenvalues and eigenvectors of\na Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), optional, allocatable :: vectors (:,:) Eigenvectors.","tags":"","loc":"interface/eigh~4.html"},{"title":"eigvalsh – SpecialMatrices","text":"public interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Diagonal . Syntax lambda = eigvalsh ( A ) Arguments A : real -valued matrix of Diagonal type.\n               It is an intent(in) argument. lambda :   Vector of eigenvalues in increasing order. Functions private module function eigvalsh_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvalsh~4.html"},{"title":"inv – SpecialMatrices","text":"public interface inv Functions private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value type( Diagonal ) Inverse of A .","tags":"","loc":"interface/inv~4.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Diagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Diagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) Functions private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Diagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Diagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors.","tags":"","loc":"interface/matmul~7.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Diagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Diagonal ), intent(in) :: A Return Value type( Diagonal )","tags":"","loc":"interface/operator(ASTERISK)~5.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Functions private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~7.html"},{"title":"size – SpecialMatrices","text":"public interface size Functions private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Diagonal matrix along a\ngiven dimension. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size~7.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Diagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Diagonal type. It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . Functions private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system where is of type Diagonal and B a standard rank-2 array. The solution matrix X has the same dimensions and kind as the right-hand side\nmatrix B . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is of type Diagonal and b a standard rank-1 array. The solution vector x has the same dimension and kind as the right-hand side\nvector b . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector.","tags":"","loc":"interface/solve~7.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Diagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. s :  Rank-1 real array returning the singular values\n         of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                  the left singular vectors of A as columns. Its\n                  size should be [n, n] . It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                  the right singular vectors of A as rows. Its\n                  size should be [n, n] . It is an intent(out) argument. Subroutines private module subroutine svd_rdp(A, u, s, vt) Compute the singular value decomposition of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), optional, allocatable :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), allocatable :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional, allocatable :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd~5.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Diagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Functions private pure module function svdvals_rdp(A) result(s) Compute the singular values of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals~5.html"},{"title":"trace – SpecialMatrices","text":"public interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Diagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. Functions private pure module function trace_rdp(A) result(tr) Compute the trace of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix.","tags":"","loc":"interface/trace~4.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a Diagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value type( Diagonal ) Transpose of the matrix.","tags":"","loc":"interface/transpose~5.html"},{"title":"Tridiagonal – SpecialMatrices","text":"public interface Tridiagonal This interface provides different methods to construct a Tridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a Tridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Tridiagonal ) :: A A = Tridiagonal ( n ) Construct a Tridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: dl (:), dv (:), du (:) type ( Tridiagonal ) :: A integer :: i dl = [( i , i = 1 , n - 1 )]; dv = [( 2 * i , i = 1 , n )]; du = [( 3 * i , i = 1 , n )] A = Tridiagonal ( dl , dv , du ) Construct a Tridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: a = 1.0_dp , b = 1.0_dp , c = 2.0_dp type ( Tridiagonal ) :: A A = Tridiagonal ( a , b , c , n ) Note Only double precision is currently supported for this matrix type. Functions private pure module function construct(dl, dv, du) result(A) Construct a Tridiagonal matrix from the rank-1 arrays dl , dv and du . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du (:) Tridiagonal elements of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function construct_constant(dl, dv, du, n) result(A) Construct a Tridiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du Tridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a Tridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix.","tags":"","loc":"interface/tridiagonal.html"},{"title":"dense – SpecialMatrices","text":"public interface dense This interface provides methods to convert a Tridiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . Functions private module function dense_rdp(A) result(B) Utility function to convert a Tridiagonal matrix to a rank-2\narray. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array.","tags":"","loc":"interface/dense~8.html"},{"title":"det – SpecialMatrices","text":"public interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Tridiagonal . Syntax d = det ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. Functions private pure module function det_rdp(A) result(d) Compute the determinant of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix.","tags":"","loc":"interface/det~5.html"},{"title":"eig – SpecialMatrices","text":"public interface eig This interface overloads the eig interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Tridiagonal . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Tridiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No specialized eigensolvers for generic Tridiagonal matrices exist\nin LAPACK. This routine thus falls back to wrapping the eig procedure from stdlib_linalg which uses *geev under the hood. Subroutines private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of\na Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors.","tags":"","loc":"interface/eig~4.html"},{"title":"eigvals – SpecialMatrices","text":"public interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Tridiagonal . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Tridiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Functions private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues.","tags":"","loc":"interface/eigvals~4.html"},{"title":"inv – SpecialMatrices","text":"public interface inv Functions private pure module function inv_rdp(A) result(B) Compute the inverse of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A .","tags":"","loc":"interface/inv~5.html"},{"title":"matmul – SpecialMatrices","text":"public interface matmul This interface overloads the Fortran intrinsic matmul for a Tridiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Tridiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) Functions private module function spmv(A, x) result(y) Compute the matrix-vector product for a Tridiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Tridiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors.","tags":"","loc":"interface/matmul~8.html"},{"title":"operator(*) – SpecialMatrices","text":"public interface operator(*) Functions private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Scalar multiplication with a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Tridiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Scalar multiplication with a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Tridiagonal ), intent(in) :: A Return Value type( Tridiagonal )","tags":"","loc":"interface/operator(ASTERISK)~6.html"},{"title":"shape – SpecialMatrices","text":"public interface shape Functions private pure module function shape_rdp(A) result(arr_shape) Return the shape of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix.","tags":"","loc":"interface/shape~8.html"},{"title":"size – SpecialMatrices","text":"public interface size Functions private pure module function size_rdp(A, dim) result(arr_size) Return the size of Tridiagonal matrix along a given dimension. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim.","tags":"","loc":"interface/size~8.html"},{"title":"solve – SpecialMatrices","text":"public interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Tridiagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b [, refine ]) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. refine (optional) : Logical switch to enable solution refinement.\n                        It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Functions private module function solve_multi_rhs(A, b, refine) result(x) Solve the linear system where is of type Tridiagonal and B a standard rank-2 array. The solution\nmatrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refined is used or not. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Solve the linear system where is of type Tridiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector.","tags":"","loc":"interface/solve~8.html"},{"title":"svd – SpecialMatrices","text":"public interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Tridiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                      Its size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. Subroutines private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows.","tags":"","loc":"interface/svd~6.html"},{"title":"svdvals – SpecialMatrices","text":"public interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Tridiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Functions private module function svdvals_rdp(A) result(s) Compute the singular values of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order.","tags":"","loc":"interface/svdvals~6.html"},{"title":"trace – SpecialMatrices","text":"public interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Tridiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. Functions private pure module function trace_rdp(A) result(tr) Compute the trace of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix.","tags":"","loc":"interface/trace~5.html"},{"title":"transpose – SpecialMatrices","text":"public interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a Tridiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . Functions private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value type( Tridiagonal ) Transpose of the matrix.","tags":"","loc":"interface/transpose~6.html"},{"title":"specialmatrices_circulant – SpecialMatrices","text":"Uses stdlib_linalg_constants fftpack Used by Descendants: circulant_constructors circulant_eigenvalue_decomposition circulant_inverse circulant_linear_solver circulant_matvecs circulant_svd circulant_utilities Interfaces public        interface Circulant This interface provides methods to construct Circulant matrices.\nGiven a vector ,\nthe associated Circulant matrix is the following [n x n] matrix Syntax integer , parameter :: n = 100 real ( dp ) :: c ( n ) type ( Circulant ) :: A call random_number ( c ) A = Circulant ( c ) Note Only double precision is currently supported for this matrix type. private pure module function construct(c) result(A) Construct a Circulant matrix from the rank-1 array c . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: c (:) Generating vector. Return Value type( Circulant ) Corresponding Circulant matrix. public        interface dense Convert a Circulant matrix to its dense representation. Syntax B = dense ( A ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private module function dense_rdp(A) result(B) Utility function to convert a Circulant matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface eig This interface overloads the eig interface from stdlib_linalg to\ncompute the eigenvalues and eigenvectors of a real-valued matrix whose type is Circulant . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Circulant .\n         It is an intent(in) argument. lambda :   Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note Eigenvalues of a circulant matrix can be efficiently computed using\nthe Fast Fourier Transform of the generating vector c . Likewise,\nits eigenvectors are simply the corresponding Fourier modes. private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors. public        interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose\ntype is Circulant . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Circulant type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Note Eigenvalues of a circulant matrix can be efficiently computed using\nthe Fast Fourier Transform of the generating vector c . private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues. public        interface inv private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Circulant matrix.\nIf A is circulant, its inverse also is circulant. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value type( Circulant ) Inverse of A . public        interface matmul This interface overloads the Fortran intrinsic matmul for a Circulant matrix, both for matrix-vector and matrix-matrix products.\nFor a matrix-matrix product , only the matrix has to be a Circulant matrix. Both and need to be\nstandard Fortran rank-2 arrays. All the underlying functions are\ndefined as pure . Syntax y = matmul ( A , x ) private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Circulant matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Circulant matrix A .\nBoth X and Y are rank-2 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:,:) Input matrix. Return Value real(kind=dp), allocatable, (:,:) Output matrix. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Circulant ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Circulant matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Circulant ), intent(in) :: A Return Value type( Circulant ) public        interface shape Utility function to return the shape of a Circulant matrix. private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size Utility function to return the size of a Circulant matrix along\na given dimension. private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Circulant matrix along a\ngiven dimension. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Circulant matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Note Linear systems characterized by a circulant matrix can be solved\nefficiently in operations using the\nFast Fourier Transform algorithm available via fftpack . private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system , where A is Circulant and B is a rank-2 array. The solution matrix X has the same\ndimension and kind as the right-hand side matrix B . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is Circulant and b a standard rank-1 array. The solution vector x has the same\ndimension and kind as the right-hand side vector b . Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a Circulant matrix . Syntax call svd ( A , s , u , vt ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional) :   Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                     Its size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. Note Singular values and singular vectors of a Circulant matrix can be\nefficiently computed based on the Fast Fourier transform. private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Circulant matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Circulant type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. private module function svdvals_rdp(A) result(s) Compute the singular values of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation of a Circulant matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Circulant .\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Circulant matrix. Arguments Type Intent Optional Attributes Name type( Circulant ), intent(in) :: A Input matrix. Return Value type( Circulant ) Transpose of the matrix. Derived Types type, public :: Circulant Base type to define a Circulant matrix of size [n x n] with elements\ngiven by the vector Constructor This interface provides methods to construct Circulant matrices.\nGiven a vector ,\nthe associated Circulant matrix is the following [n x n] matrix Read more… private\n\n                    pure, module\n                    function construct (c) Construct a Circulant matrix from the rank-1 array c .","tags":"","loc":"module/specialmatrices_circulant.html"},{"title":"specialmatrices_bidiagonal – SpecialMatrices","text":"Uses stdlib_linalg_constants Used by Descendants: bidiagonal_constructors bidiagonal_determinant bidiagonal_eigenvalue_decomposition bidiagonal_linear_solver bidiagonal_matvecs bidiagonal_singular_value_decomposition bidiagonal_trace bidiagonal_utils Interfaces public        interface Bidiagonal This interface provides different methods to construct a Bidiagonal matrix. Only the non-zero elements of are\nstored, i.e. if is lower-bidiagonal or if is upper-bidiagonal. Warning By default, the matrix is lower-bidiagonal. To create an upper-\nbidiagonal, set A%which = \"U\" . Syntax Construct a Bidiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Bidiagonal ) :: A A = Bidiagonal ( n ) Construct a Bidiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( Bidiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Bidiagonal ( dv , ev ) Construct a Bidiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( Bidiagonal ) :: A A = Bidiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dv, ev, which) result(A) Construct a Bidiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) Bidiagonal elements of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-diagonal. Return Value type( Bidiagonal ) Bidiagonal matrix. private pure module function construct_constant(d, e, n, which) result(A) Construct a Bidiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Bidiagonal elements of the matrix. real(kind=dp), intent(in) :: e Bidiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. character(len=1), intent(in), optional :: which Whether A is lower- or upper-bidiagonal. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix. private pure module function initialize(n) result(A) Construct a Bidiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Bidiagonal ) Symmetric Bidiagonal matrix. public        interface dense This interface provides methods to convert a Bidiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private module function dense_rdp(A) result(B) Utility function to convert a Bidiagonal matrix to a\nrank-2 array. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Bidiagonal . Syntax d = det ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. private pure module function det_rdp(A) result(d) Compute the determinant of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix. public        interface eig This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Bidiagonal . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Bidiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No specialized eigensolvers for generic Bidiagonal matrices exist\nin LAPACK. This routine thus falls back to wrapping the eig procedure from stdlib_linalg which uses *geev under the hood. private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors. public        interface eigvals This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Bidiagonal . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Bidiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues. public        interface inv private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A . public        interface matmul This interface overloads the Fortran intrinsic matmul for a Bidiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Bidiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) private module function spmv(A, x) result(y) Compute the matrix-vector product for a Bidiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in), target :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Bidiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Bidiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Bidiagonal ), intent(in) :: A Return Value type( Bidiagonal ) public        interface shape private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Bidiagonal matrix along\na given dimension. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Bidiagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . private pure module function solve_multi_rhs(A, b) result(x) Solve the linear system where is of type Bidiagonal and B a standard rank-2 array. The solution matrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is of type Bidiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, target, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Bidiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional) :   Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                     Its size should be [n, n] . It is an intent(out) argument. vt (optional):   Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows.\n                     Its size should be [n, n] . It is an intent(out) argument. private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Bidiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. private module function svdvals_rdp(A) result(s) Compute the singular values of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Bidiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. private pure module function trace_rdp(A) result(tr) Compute the trace of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose of a Bidiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Bidiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Bidiagonal matrix. Arguments Type Intent Optional Attributes Name type( Bidiagonal ), intent(in) :: A Input matrix. Return Value type( Bidiagonal ) Transpose of the matrix. Derived Types type, public :: Bidiagonal Base type used to define a Bidiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dv (size n ) and ev (size n-1 ). Constructor This interface provides different methods to construct a Bidiagonal matrix. Only the non-zero elements of are\nstored, i.e. Read more… private\n\n                    pure, module\n                    function construct (dv, ev, which) Construct a Bidiagonal matrix from the rank-1 arrays dv and ev . private\n\n                    pure, module\n                    function construct_constant (d, e, n, which) Construct a Bidiagonal matrix with constant diagonal elements. private\n\n                    pure, module\n                    function initialize (n) Construct a Bidiagonal matrix filled with zeros.","tags":"","loc":"module/specialmatrices_bidiagonal.html"},{"title":"specialmatrices_toeplitz – SpecialMatrices","text":"Uses stdlib_linalg stdlib_linalg_constants specialmatrices_circulant Used by Descendants: toeplitz_constructors toeplitz_eigendecomposition toeplitz_linear_solver toeplitz_matvecs toeplitz_svd toeplitz_utilities Interfaces public        interface Circulant Utility function to embed an m x n Toeplitz matrix into an\n(m+n) x (m+n) Circulant matrix. private pure module function Toeplitz2Circulant(T) result(C) Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: T Return Value type( Circulant ) public        interface Toeplitz This interface provides methods to construct Toeplitz matrices.\nGiven a vector vc specifying the first column of the matrix and a\nvector vr specifying its first row, the associated Toeplitz matrix is the following matrix Syntax integer , parameter :: m = 100 , n = 200 real ( dp ) :: vc ( n ), vr ( n ) type ( Toeplitz ) :: A call random_number ( vc ) ; call random_number ( vr ) A = Toeplitz ( vc , vr ) Warning The element is read from the first entry of the vector vc . The first entry of vr is not referenced. Note Only double precision is currently supported for this matrix type. private pure module function construct(vc, vr) result(A) Construct a Toeplitz matrix from the rank-1 arrays vc and vr . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vc (:) First column of the matrix. real(kind=dp), intent(in) :: vr (:) First row of the matrix. Return Value type( Toeplitz ) Corresponding Toeplitz matrix. public        interface dense Convert a Toeplitz matrix to a standard rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private pure module function dense_rdp(A) result(B) Utility function to convert a Toeplitz matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface eig This interface overloads the eig interface from stdlib_linalg to\ncompute the eigenvalues and eigenvectors of a real-valued matrix whose type is Toeplitz . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Toeplitz .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order.\n               It is an intent(out) argument. left (optional) : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No analytic expression exist for the eigendecomposition of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function eig from stdlib_linalg is used. private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors. public        interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose\ntype is Toeplitz . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Toeplitz type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. Note No analytic expression exist for the eigenvalues of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function eigvals from stdlib_linalg is used. private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues. public        interface matmul This interface overloads the Fortran intrinsic matmul for a Toeplitz matrix, both for matrix-vector and matrix-matrix products.\nFor a matrix-matrix product , only the matrix has to be a Toeplitz matrix. Both and need to be\nstandard Fortran rank-2 arrays. All the underlying functions are\ndefined as pure . Syntax y = matmul ( A , x ) Note Matrix-vector products for Toeplitz matrices can be efficiently\ncomputed by embedding the Toeplitz matrix into a Circulant matrix\nof size [m+n x m+n] and using the Fast Fourier Transform provided\nby fftpack . private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Toeplitz matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Toeplitz matrix A .\nBoth X and Y are rank-2 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:,:) Input matrix. Return Value real(kind=dp), allocatable, (:,:) Output matrix. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Toeplitz ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Toeplitz matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Toeplitz ), intent(in) :: A Return Value type( Toeplitz ) public        interface shape Utility function to return the size of a Toeplitz matrix. private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size Utility function to return the size of Toeplitz matrix along a\ngiven dimension. private pure module function size_rdp(A, dim) result(arr_size) Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Toeplitz matrix. It also enables to solve a linear system with multiple\nright-hand sides. Syntax To solve a system with being of type Toeplitz : x = solve ( A , b ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . Note Under the hood, a gmres solver is being used along with a\nCirculant preconditioner. By design, gmres is run until a\nrelative tolerance of is reached. private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system , where A is Toeplitz and B is a rank-2 array. The solution matrix X has the same dimension\nand kind as the right-hand side matrix B . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is Toeplitz and b a standard rank-1 array. The solution vector x has the same\ndimension and kind as the right-hand side vector b . Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a Toeplitz matrix . Syntax call svd ( A , s , u , vt ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] . It is an intent(out) argument. Note No analytic expression exist for the singular value of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function svdvals from stdlib_linalg is used. private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Toeplitz matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. Note No analytic expression exist for the singular values of a general Toeplitz matrix. Under the hood, the matrix A is converted to\nits dense representation and the function svdvals from stdlib_linalg is used. private module function svdvals_rdp(A) result(s) Compute the singular values of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation of a Toeplitz matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Toeplitz type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Toeplitz matrix. Arguments Type Intent Optional Attributes Name type( Toeplitz ), intent(in) :: A Input matrix. Return Value type( Toeplitz ) Transpose of the matrix. Derived Types type, public :: Toeplitz Base type to define a Toeplitz matrix of size [m x n]. The first\ncolumn is given by the vector vc while the first row is given by vr . Constructor This interface provides methods to construct Toeplitz matrices.\nGiven a vector vc specifying the first column of the matrix and a\nvector vr specifying its first row, the associated Toeplitz matrix is the following matrix Read more… private\n\n                    pure, module\n                    function construct (vc, vr) Construct a Toeplitz matrix from the rank-1 arrays vc and vr .","tags":"","loc":"module/specialmatrices_toeplitz.html"},{"title":"specialmatrices_symtridiagonal – SpecialMatrices","text":"Uses stdlib_linalg_constants Used by Descendants: symtridiagonal_constructors symtridiagonal_determinant symtridiagonal_eigenvalue_decomposition symtridiagonal_linear_solver symtridiagonal_matvecs symtridiagonal_singular_value_decomposition symtridiagonal_trace symtridiagonal_utils Interfaces public        interface SymTridiagonal This interface provides different methods to construct a SymTridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a SymTridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( SymTridiagonal ) :: A A = SymTridiagonal ( n ) Construct a SymTridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: ev (:), dv (:) type ( SymTridiagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; ev = [( 2 * i , i = 1 , n )] A = Tridiagonal ( dv , ev ) Construct a SymTridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: d = 1.0_dp , e = 2.0_dp type ( SymTridiagonal ) :: A A = SymTridiagonal ( d , e , n ) Note Only double precision is currently supported for this matrix type. Note If is known to be symmetric positive definite, it can be\nconstructed as A = SymTridiagonal(dv, ev, ifposdef=.true.) :w private pure module function construct(dv, ev, isposdef) result(A) Construct a SymTridiagonal matrix from the rank-1 arrays dv and ev . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: ev (:) SymTridiagonal elements of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function construct_constant(d, e, n, isposdef) result(A) Construct a SymTridiagonal matrix with constant diagonal\nelements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d SymTridiagonal elements of the matrix. real(kind=dp), intent(in) :: e SymTridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. logical(kind=lk), intent(in), optional :: isposdef Whether A is positive-definite or not. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a SymTridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( SymTridiagonal ) Symmetric Tridiagonal matrix. public        interface dense This interface provides methods to convert a SymTridiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private module function dense_rdp(A) result(B) Convert a SymTridiagonal matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type SymTridiagonal . Syntax d = det ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. private pure module function det_rdp(A) result(d) Compute the determinant of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix. public        interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a matrix whose\ntype is SymTridiagonal . Syntax call eigh ( A , lambda [, vectors ]) Arguments A :  Matrix of SymTridiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors (optional)  :  Rank-2 array of the same kind as A returning the eigenvectors of A .\n                           It is an intent(out) argument. private module subroutine eigh_rdp(A, lambda, vectors) Compute the eigenvalues and eigenvectors of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), optional, allocatable, target :: vectors (:,:) Eigenvectors. public        interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a matrix whose\ntype is SymTridiagonal . Syntax lambda = eigvalsh ( A ) Arguments A : real -valued matrix of SymTridiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. private module function eigvalsh_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues. public        interface inv private pure module function inv_rdp(A) result(B) Compute the inverse of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A . public        interface matmul This interface overloads the Fortran intrinsic matmul for a SymTridiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a SymTridiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) private module function spmv(A, x) result(y) Compute the matrix-vector product for a SymTridiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a SymTridiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Scalar multiplication with a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( SymTridiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Scalar multiplication with a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( SymTridiagonal ), intent(in) :: A Return Value type( SymTridiagonal ) public        interface shape private pure module function shape_rdp(A) result(arr_shape) Return the shape of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size private pure module function size_rdp(A, dim) result(arr_size) Return the size of SymTridiagonal matrix along a given\ndimension. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a SymTridiagonal matrix. It also enables to solve a linear system\nwith multiple right-hand sides. Syntax x = solve ( A , b [, refine ]) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. refine (optional) : Logical switch to enable solution refinement. x :  Solution of the linear system.\n         It has the same type and shape as b . private module function solve_multi_rhs(A, b, refine) result(x) Solve the linear system where is of type SymTridiagonal and B a standard rank-2 array. The solution\nmatrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement of the solution is used or not. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Solve the linear system where is of type SymTridiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement of the solution is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to\ncompute the the singular value decomposition of a SymTridiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional, allocatable :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional, allocatable :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a SymTridiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. private module function svdvals_rdp(A) result(s) Compute the singular values of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type SymTridiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. private pure module function trace_rdp(A) result(tr) Compute the trace of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a SymTridiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of SymTridiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Compute the transpose of a SymTridiagonal matrix. Arguments Type Intent Optional Attributes Name type( SymTridiagonal ), intent(in) :: A Input matrix. Return Value type( SymTridiagonal ) Transpose of the matrix. Derived Types type, public :: SymTridiagonal Base type used to define a SymTridiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dv (size n ) and ev (size n-1 ). Constructor This interface provides different methods to construct a SymTridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Read more… private\n\n                    pure, module\n                    function construct (dv, ev, isposdef) Construct a SymTridiagonal matrix from the rank-1 arrays dv and ev . private\n\n                    pure, module\n                    function construct_constant (d, e, n, isposdef) Construct a SymTridiagonal matrix with constant diagonal\nelements. private\n\n                    pure, module\n                    function initialize (n) Construct a SymTridiagonal matrix filled with zeros.","tags":"","loc":"module/specialmatrices_symtridiagonal.html"},{"title":"specialmatrices_poisson2D – SpecialMatrices","text":"Uses stdlib_linalg_constants specialmatrices_strang Used by Descendants: poisson2D_constructors poisson2D_eigh poisson2D_matvecs poisson2D_solve poisson2D_utils Interfaces public        interface Poisson2D Constructor for generating a Poisson2D matrix. The matrix corresponds\nto the standard second-order accurate finite-difference approximation\nof the Laplace operator with homogeneous Dirichlet boundary conditions. Syntax Construct the finite-difference approximation of the Laplace operator\n   on the rectangular domain using 128 points in the horizontal direction and 256 in the\n   vertical one. type ( Poisson2D ) :: A integer , parameter :: nx = 128 , ny = 256 real ( dp ), parameter :: Lx = 1.0_dp , Ly = 2.0_dp A = Poisson2D ( nx , ny , Lx , Ly ) Note Only doube precision is currently supported for this matrix type. Note Note that Lx and Ly are optional. If not specified, they default\nto 1.0_dp . private pure module function initialize(nx, ny, Lx, Ly) result(A) Utility function to construct a Poisson2D matrix. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: nx Number of grid points in each direction. integer(kind=ilp), intent(in) :: ny Number of grid points in each direction. real(kind=dp), intent(in), optional :: Lx Physical extent of each dimension. real(kind=dp), intent(in), optional :: Ly Physical extent of each dimension. Return Value type( Poisson2D ) Corresponding Poisson2D matrix. public        interface dense Cnvert a matrix of type Poisson2D to its dense representation as a\nstandard rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. B :  Rank-2 real array corresponding to the dense representation\n         of A . private pure module function dense_rdp(A) result(B) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Dense representation. public        interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of the Poisson2D matrix . Syntax call eigh ( A , lambda , vectors ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. lambda : Rank-1 real array returning the eigenvalues of A in\n            increasing order. It is an intent(out) argument. vectors :   Rank-2 real array returning the eigenvectors of A .\n               It is an intent(out) argument. Note Both the eigenvalues and eigenvectors of the Poisson2D matrix are\nknown analytically and can thus be constructed efficiently. private module subroutine eigh_rdp(A, lambda, vectors) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable, target :: lambda (:) Eigenvalues. real(kind=dp), intent(out), allocatable :: vectors (:,:) public        interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of the Poisson2D matrix . Syntax lambda = eigvalsh ( A ) Arguments A :  Matrix of Poisson2D type. It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. Note The eigenvalues of the Poisson2D matrix are known analytically\nand can thus be computed efficiently. private module function eigvalsh_rdp(A) result(lambda) Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, target, (:) Eigenvalues. public        interface matmul This interface overloads the Fortran intrinsic matmul for a Poisson2D matrixn, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Poisson2D matrix. Both and are\nstandard Fortran rank-2 arrays. Syntax y = matmul ( A , x ) private module function spmv(A, x) result(y) Compute the matrix-vector product for a Poisson2D matrix .\nBoth x and y are rank-1 arrays with the same kind as A . Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), allocatable, target, (:) Output vector. private module function spmvs(A, x) result(y) Compute the matrix-matrix product for a Poisson2D matrix . and are rank-2 arrays of appropriate size with the same kind as . Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target, contiguous :: x (:,:) Input vectors. Return Value real(kind=dp), allocatable, target, (:,:) Output vectors. public        interface shape Utility function to return the shape a Poisson2D matrix . private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of the Poisson2D matrix. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size Utility function to return the size of a Poisson2D matrix along a given dimension. private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of a Poisson2D matrix along a given dimension. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Corresponding size. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a system where is a Poisson2D matrix.\nIt also enables to solve a linear system with multiple right-hand\nsides. Syntax x = solve ( A , b ) Arguments A :  Matrix of type Poisson2D . It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . Note It uses a fast Poisson solver leveraging the discrete sine\ntransform provided by fftpack . Only homogeneous Dirichlet boundary\nconditions are handled by default. If non-homogeneous Dirichlet\nboundary conditions need to be used, they can be implemented by\nmodifiying the right-hand side vector. Neuman-type boundary\nconditions are not supported at all. private pure module function solve_multi_rhs(A, b) result(x) Solve the linear system using a fast Poisson solver. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system using a fast Poisson solver. Arguments Type Intent Optional Attributes Name type( Poisson2D ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, target, (:) Solution vector. Derived Types type, public :: Poisson2D Base type used to define a Poisson2D matrix on a rectangular domain\ndiscretized with nx and ny points in each direction and\ncorresponding grid spacings dx and dy . Constructor Constructor for generating a Poisson2D matrix. The matrix corresponds\nto the standard second-order accurate finite-difference approximation\nof the Laplace operator with homogeneous Dirichlet boundary conditions. Read more… private\n\n                    pure, module\n                    function initialize (nx, ny, Lx, Ly) Utility function to construct a Poisson2D matrix.","tags":"","loc":"module/specialmatrices_poisson2d.html"},{"title":"SpecialMatrices – SpecialMatrices","text":"Uses specialmatrices_diagonal specialmatrices_strang specialmatrices_symtridiagonal specialmatrices_toeplitz specialmatrices_circulant specialmatrices_bidiagonal specialmatrices_tridiagonal specialmatrices_poisson2D Subroutines public  subroutine say_hello () Arguments None","tags":"","loc":"module/specialmatrices.html"},{"title":"specialmatrices_strang – SpecialMatrices","text":"Uses stdlib_linalg_constants Used by Descendants: strang_constructors strang_determinant strang_eigh strang_linear_solver strang_matvecs strang_utils strange_trace Interfaces public        interface Strang Constructor for generating the Strang matrix of size n . The\nmatrix corresponds to the standard 3-point finite-difference\napproximation of the 1D Laplace operator with unit grid-spacing\n( ) and homogeneous Dirichlet boundary conditions.\nIt reads Syntax Construct a Strang matrix of size 100. integer , parameter :: n = 100 type ( Strang ) :: S S = Strang ( n ) Note Only double precision is currently supported for this matrix type. private pure module function initialize(n) result(A) Construct the Strang matrix of size n . Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Strang ) Strang matrix of size n . public        interface dense Convert a matrix of type Strang to its dense representation as a\nstandard rank-2 array Syntax B = dense ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. B :  Rank-2 array representation fo the matrix . private pure module function dense_rdp(A) result(B) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Dense representation. public        interface det This interface overloads the det interface from stdlib_linalg to compute the determinant where is of type Strang . Syntax d = det ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. d :  Determinant of the matrix. private pure module function det_rdp(A) result(d) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix. public        interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a Strang matrix. Syntax call eigh ( A , lambda , vectors ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors :  Rank-2 real array of size [n x n] returning the\n               eigenvectors of A . It is an intent(out) argument. Note Eigenvalues and eigenvectors of the Strang matrix are known\nanalytically and can thus be constructed very efficiently. private pure module subroutine eigh_rdp(A, lambda, vectors) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), allocatable :: vectors (:,:) Eigenvectors. public        interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a Strang matrix. Note that these\neigenvalues are known analytically. Syntax lambda = eigvalsh ( A ) Arguments A :  Matrix of type Strang . It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. private pure module function eigvalsh_rdp(A) result(lambda) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues. public        interface matmul This interface overloads the Fortran intrinsic matmul for the Strang matrix, both for matrix-vector and matrix-matrix products.\nFor matrix-matrix product , only can be a Strang matrix. Both and are standard rank-2 arrays. All\nunderlying functions are defined as pure . Syntax y = matmul ( A , x ) private pure module function spmv(A, x) result(y) Driver for the matrix-vector product. Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Driver for the matrix-matrix product. Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vector. Return Value real(kind=dp), allocatable, (:,:) Output vector. public        interface shape Utility function returning the shape of a Strang matrix . private pure module function shape_rdp(A) result(arr_shape) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size Utility function returning the size of a Strang matrix along a given dimension. private pure module function size_rdp(A, dim) result(arr_size) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in) :: dim Queried dimension. Return Value integer(kind=ilp) Corresponding size. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a system where is a Strang matrix.\nIt also enables to solve a linear system with multiple right-hand\nsides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Strang type. It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . private module function solve_multi_rhs(A, b, refine) result(x) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector. public        interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Strang . Strang tr = trace ( A ) Arguments A :  Matrix of Strang type. It is an intent(in) argument. tr :  Trace of the matrix. private pure module function trace_rdp(A) result(tr) Arguments Type Intent Optional Attributes Name type( Strang ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix. Derived Types type, public :: Strang Base type used to define the Strang matrix. Components Type Visibility Attributes Name Initial integer(kind=ilp), public :: n Dimension of the matrix. Constructor Constructor for generating the Strang matrix of size n . The\nmatrix corresponds to the standard 3-point finite-difference\napproximation of the 1D Laplace operator with unit grid-spacing\n( ) and homogeneous Dirichlet boundary conditions.\nIt reads Read more… private\n\n                    pure, module\n                    function initialize (n) Construct the Strang matrix of size n .","tags":"","loc":"module/specialmatrices_strang.html"},{"title":"specialmatrices_diagonal – SpecialMatrices","text":"Uses stdlib_linalg_constants Used by Descendants: diagonal_constructors diagonal_determinant diagonal_hermitian_eigenvalue_decomposition diagonal_inverse diagonal_linear_solver diagonal_matvecs diagonal_singular_value_decomposition diagonal_trace diagonal_utilities Interfaces public        interface Diagonal This interface provides different methods to construct a Diagonal matrix. Only the diagonal elements of are being stored, i.e. Syntax Construct a Diagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Diagonal ) :: A A = Diagonal ( n ) Construct a Diagonal matrix from a vector. integer , parameter :: n = 100 real ( dp ), allocatable :: dv (:) type ( Diagonal ) :: A integer :: i dv = [( i , i = 1 , n )]; A = Diagonal ( dv ) Construct a Diagonal matrix with constant diagonal element. integer , parameter :: n = 100 real ( dp ), parameter :: d = 2.0_dp type ( Diagonal ) :: A A = Diagonal ( d , n ) Construct a Diagonal matrix from a standard rank-2 array. integer , parameter :: n = 100 real ( dp ) :: B ( n , n ) type ( Diagonal ) :: A call random_number ( B ); A = Diagonal ( B ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dv) result(A) Utility function to construct a Diagonal matrix from a rank-1\narray. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dv (:) Diagonal elements of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function construct_constant(d, n) result(A) Utility function to construct a Diagonal matrix with constant\ndiagonal element. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: d Constant diagonal element of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. private module function dense_to_diag(A) result(B) Utility function to construct a Diagonal matrix from a rank-2\narray. The resulting matrix is constructed from the diagonal\nelement of the input matrix, even if the latter is not diagonal. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Dense matrix from which to construct the Diagonal one. Return Value type( Diagonal ) Corresponding diagonal matrix. private pure module function initialize(n) result(A) Utility function to construct a Diagonal matrix filled with\nzeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Diagonal ) Corresponding diagonal matrix. public        interface dense This interface provides methods to convert a Diagonal matrix to a\nregular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private module function dense_rdp(A) result(B) Convert a Diagonal matrix to a rank-2 array. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Diagonal . Syntax d = det ( A ) Arguments A :  Matrix of Diagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. private pure module function det_rdp(A) result(d) Compute the determinant of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix. public        interface eigh This interface overloads the eigh interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Diagonal . Syntax call eigh ( A , lambda [, vectors ]) Arguments A : real -valued matrix of Diagonal .\n               It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. vectors (optional)  :  Rank-2 array of the same kind as A returning the eigenvectors of A . It is\n                           an intent(out) argument. private module subroutine eigh_rdp(A, lambda, vectors) Utility function to compute the eigenvalues and eigenvectors of\na Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), allocatable :: lambda (:) Eigenvalues. real(kind=dp), intent(out), optional, allocatable :: vectors (:,:) Eigenvectors. public        interface eigvalsh This interface overloads the eigvalsh interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Diagonal . Syntax lambda = eigvalsh ( A ) Arguments A : real -valued matrix of Diagonal type.\n               It is an intent(in) argument. lambda :   Vector of eigenvalues in increasing order. private module function eigvalsh_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Eigenvalues. public        interface inv private pure module function inv_rdp(A) result(B) Utility function to compute the inverse of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value type( Diagonal ) Inverse of A . public        interface matmul This interface overloads the Fortran intrinsic matmul for a Diagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Diagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) private pure module function spmv(A, x) result(y) Compute the matrix-vector product for a Diagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: x (:) Input vector. Return Value real(kind=dp), allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Diagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Utility function to perform a scalar multiplication with a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Diagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Utility function to perform a scalar multiplication with a Diagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Diagonal ), intent(in) :: A Return Value type( Diagonal ) public        interface shape private pure module function shape_rdp(A) result(arr_shape) Utility function to get the shape of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size private pure module function size_rdp(A, dim) result(arr_size) Utility function to return the size of Diagonal matrix along a\ngiven dimension. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Diagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b ) Arguments A :  Matrix of Diagonal type. It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. x :  Solution of the linear system. It has the same type and\n         shape as b . private pure module function solve_multi_rhs(A, B) result(X) Solve the linear system where is of type Diagonal and B a standard rank-2 array. The solution matrix X has the same dimensions and kind as the right-hand side\nmatrix B . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: B (:,:) Right-hand side vectors. Return Value real(kind=dp), allocatable, (:,:) Solution vectors. private pure module function solve_single_rhs(A, b) result(x) Solve the linear system where is of type Diagonal and b a standard rank-1 array. The solution vector x has the same dimension and kind as the right-hand side\nvector b . Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:) Right-hand side vector. Return Value real(kind=dp), allocatable, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Diagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. s :  Rank-1 real array returning the singular values\n         of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                  the left singular vectors of A as columns. Its\n                  size should be [n, n] . It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                  the right singular vectors of A as rows. Its\n                  size should be [n, n] . It is an intent(out) argument. private module subroutine svd_rdp(A, u, s, vt) Compute the singular value decomposition of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out), optional, allocatable :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), allocatable :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional, allocatable :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Diagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. private pure module function svdvals_rdp(A) result(s) Compute the singular values of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Diagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. private pure module function trace_rdp(A) result(tr) Compute the trace of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a Diagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Diagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Diagonal matrix. Arguments Type Intent Optional Attributes Name type( Diagonal ), intent(in) :: A Input matrix. Return Value type( Diagonal ) Transpose of the matrix. Derived Types type, public :: Diagonal Base type used to define a Diagonal matrix of size [n x n] with diagonal elements given by the rank-1 array dv . Constructor This interface provides different methods to construct a Diagonal matrix. Only the diagonal elements of are being stored, i.e. Read more… private\n\n                    pure, module\n                    function construct (dv) Utility function to construct a Diagonal matrix from a rank-1\narray. private\n\n                    pure, module\n                    function construct_constant (d, n) Utility function to construct a Diagonal matrix with constant\ndiagonal element. private\n\n                    module\n                    function dense_to_diag (A) Utility function to construct a Diagonal matrix from a rank-2\narray. The resulting matrix is constructed from the diagonal\nelement of the input matrix, even if the latter is not diagonal. private\n\n                    pure, module\n                    function initialize (n) Utility function to construct a Diagonal matrix filled with\nzeros.","tags":"","loc":"module/specialmatrices_diagonal.html"},{"title":"specialmatrices_tridiagonal – SpecialMatrices","text":"Uses stdlib_linalg_constants Used by Descendants: tridiagonal_constructors tridiagonal_determinant tridiagonal_eigenvalue_decomposition tridiagonal_linear_solver tridiagonal_matvecs tridiagonal_singular_value_decomposition tridiagonal_trace tridiagonal_utils Interfaces public        interface Tridiagonal This interface provides different methods to construct a Tridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Syntax Construct a Tridiagonal matrix filled with zeros: integer , parameter :: n = 100 type ( Tridiagonal ) :: A A = Tridiagonal ( n ) Construct a Tridiagonal matrix from rank-1 arrays: integer , parameter :: n real ( dp ), allocatable :: dl (:), dv (:), du (:) type ( Tridiagonal ) :: A integer :: i dl = [( i , i = 1 , n - 1 )]; dv = [( 2 * i , i = 1 , n )]; du = [( 3 * i , i = 1 , n )] A = Tridiagonal ( dl , dv , du ) Construct a Tridiagonal matrix with constant diagonals: integer , parameter :: n real ( dp ), parameter :: a = 1.0_dp , b = 1.0_dp , c = 2.0_dp type ( Tridiagonal ) :: A A = Tridiagonal ( a , b , c , n ) Note Only double precision is currently supported for this matrix type. private pure module function construct(dl, dv, du) result(A) Construct a Tridiagonal matrix from the rank-1 arrays dl , dv and du . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv (:) Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du (:) Tridiagonal elements of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function construct_constant(dl, dv, du, n) result(A) Construct a Tridiagonal matrix with constant diagonal elements. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dl Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: dv Tridiagonal elements of the matrix. real(kind=dp), intent(in) :: du Tridiagonal elements of the matrix. integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. private pure module function initialize(n) result(A) Construct a Tridiagonal matrix filled with zeros. Arguments Type Intent Optional Attributes Name integer(kind=ilp), intent(in) :: n Dimension of the matrix. Return Value type( Tridiagonal ) Tridiagonal matrix. public        interface dense This interface provides methods to convert a Tridiagonal matrix\nto a regular rank-2 array. Syntax B = dense ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. B :  Rank-2 array representation of the matrix . private module function dense_rdp(A) result(B) Utility function to convert a Tridiagonal matrix to a rank-2\narray. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input diagonal matrix. Return Value real(kind=dp), allocatable, (:,:) Output dense rank-2 array. public        interface det This interface overloads the det interface from stdlib_linag to\ncompute the determinant where is of type Tridiagonal . Syntax d = det ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is in an intent(in) argument. d :  Determinant of the matrix. private pure module function det_rdp(A) result(d) Compute the determinant of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Determinant of the matrix. public        interface eig This interface overloads the eig interface from stdlib_linalg to compute the eigenvalues and eigenvectors of a real-valued matrix whose type is Tridiagonal . Syntax call eig ( A , lambda [, left ] [, right ]) Arguments A : real -valued matrix of Tridiagonal .\n         It is an intent(in) argument. lambda :  Rank-1 real array returning the eigenvalues of A in increasing order. It is an intent(out) argument. left (optional)  : complex rank-2 array of the same kind as A returning the left eigenvectors of A .\n                        It is an intent(out) argument. right (optional) : complex rank-2 array of the same kind as A returning the right eigenvectors of A .\n                        It is an intent(out) argument. Note No specialized eigensolvers for generic Tridiagonal matrices exist\nin LAPACK. This routine thus falls back to wrapping the eig procedure from stdlib_linalg which uses *geev under the hood. private module subroutine eig_rdp(A, lambda, left, right) Utility function to compute the eigenvalues and eigenvectors of\na Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. complex(kind=dp), intent(out) :: lambda (:) Eigenvalues. complex(kind=dp), intent(out), optional :: left (:,:) Eigenvectors. complex(kind=dp), intent(out), optional :: right (:,:) Eigenvectors. public        interface eigvals This interface overloads the eigvals interface from stdlib_linalg to compute the eigenvalues of a real-valued matrix whose type is Tridiagonal . Syntax lambda = eigvals ( A ) Arguments A : real -valued matrix of Tridiagonal type.\n         It is an intent(in) argument. lambda :  Vector of eigenvalues in increasing order. private module function eigvals_rdp(A) result(lambda) Utility function to compute the eigenvalues of a real Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value complex(kind=dp), allocatable, (:) Eigenvalues. public        interface inv private pure module function inv_rdp(A) result(B) Compute the inverse of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:,:) Inverse of A . public        interface matmul This interface overloads the Fortran intrinsic matmul for a Tridiagonal matrix, both for matrix-vector and matrix-matrix\nproducts. For a matrix-matrix product , only the matrix has to be a Tridiagonal matrix. Both and need to be standard Fortran rank-2 arrays. All the underlying\nfunctions are defined as pure . Syntax y = matmul ( A , x ) private module function spmv(A, x) result(y) Compute the matrix-vector product for a Tridiagonal matrix . Both x and y are rank-1 arrays with the same\nkind as A . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in), target :: x (:) Input vector. Return Value real(kind=dp), target, allocatable, (:) Output vector. private pure module function spmvs(A, X) result(Y) Compute the matrix-matrix product for a Tridiagonal matrix and a dense matrix (rank-2 array). is\nalso a rank-2 array with the same dimensions as . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(in) :: X (:,:) Input vectors. Return Value real(kind=dp), allocatable, (:,:) Output vectors. public        interface operator(*) private pure module function scalar_multiplication_bis_rdp(A, alpha) result(B) Scalar multiplication with a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A real(kind=dp), intent(in) :: alpha Return Value type( Tridiagonal ) private pure module function scalar_multiplication_rdp(alpha, A) result(B) Scalar multiplication with a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: alpha type( Tridiagonal ), intent(in) :: A Return Value type( Tridiagonal ) public        interface shape private pure module function shape_rdp(A) result(arr_shape) Return the shape of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value integer(kind=ilp), (2) Shape of the matrix. public        interface size private pure module function size_rdp(A, dim) result(arr_size) Return the size of Tridiagonal matrix along a given dimension. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. integer(kind=ilp), intent(in), optional :: dim Queried dimension. Return Value integer(kind=ilp) Size of the matrix along the dimension dim. public        interface solve This interface overloads the solve interface from stdlib_linalg for solving a linear system where is a Tridiagonal matrix. It also enables to solve a linear system with\nmultiple right-hand sides. Syntax x = solve ( A , b [, refine ]) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. b :  Rank-1 or rank-2 array defining the right-hand side(s).\n         It is an intent(in) argument. refine (optional) : Logical switch to enable solution refinement.\n                        It is an intent(in) argument. x :  Solution of the linear system.\n         It has the same type and shape as b . private module function solve_multi_rhs(A, b, refine) result(x) Solve the linear system where is of type Tridiagonal and B a standard rank-2 array. The solution\nmatrix X has the same dimensions and kind as B . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in) :: b (:,:) Right-hand side vectors. logical(kind=lk), intent(in), optional :: refine Whether iterative refined is used or not. Return Value real(kind=dp), allocatable, target, (:,:) Solution vectors. private module function solve_single_rhs(A, b, refine) result(x) Solve the linear system where is of type Tridiagonal and b a standard rank-1 array. The solution\nvector x has the same dimension and kind as b . Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Coefficient matrix. real(kind=dp), intent(in), target :: b (:) Right-hand side vector. logical(kind=lk), intent(in), optional :: refine Whether iterative refinement is used or not. Return Value real(kind=dp), allocatable, target, (:) Solution vector. public        interface svd This interface overloads the svd interface from stdlib_linalg to compute the the singular value decomposition of a Tridiagonal matrix . Syntax call svd ( A , s [, u ] [, vt ]) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. s :  Rank-1 array real array returning the singular values of A . It is an intent(out) argument. u (optional)  :  Rank-2 array of the same kind as A returning\n                     the left singular vectors of A as columns.\n                      Its size should be [n, n] .\n                     It is an intent(out) argument. vt (optional) :  Rank-2 array of the same kind as A returning\n                     the right singular vectors of A as rows. Its\n                     size should be [n, n] .\n                     It is an intent(out) argument. private module subroutine svd_rdp(A, s, u, vt) Compute the singular value decomposition of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. real(kind=dp), intent(out) :: s (:) Singular values in descending order. real(kind=dp), intent(out), optional :: u (:,:) Left singular vectors as columns. real(kind=dp), intent(out), optional :: vt (:,:) Right singular vectors as rows. public        interface svdvals This interface overloads the svdvals interface from stdlib_linalg to compute the singular values of a Tridiagonal matrix . Syntax s = svdvals ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. s :  Vector of singular values sorted in decreasing order. private module function svdvals_rdp(A) result(s) Compute the singular values of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp), allocatable, (:) Singular values in descending order. public        interface trace This interface overloads the trace interface from stdlib_linalg to compute the trace of a matrix of type Tridiagonal . Syntax tr = trace ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. tr :  Trace of the matrix. private pure module function trace_rdp(A) result(tr) Compute the trace of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value real(kind=dp) Trace of the matrix. public        interface transpose This interface overloads the Fortran intrinsic procedure to define\nthe transpose operation for a Tridiagonal matrix. Syntax B = transpose ( A ) Arguments A :  Matrix of Tridiagonal type.\n         It is an intent(in) argument. B :  Resulting transposed matrix. It is of the same type as A . private pure module function transpose_rdp(A) result(B) Utility function to compute the transpose of a Tridiagonal matrix. Arguments Type Intent Optional Attributes Name type( Tridiagonal ), intent(in) :: A Input matrix. Return Value type( Tridiagonal ) Transpose of the matrix. Derived Types type, public :: Tridiagonal Base type used to define a Tridiagonal matrix of size [n, n] with diagonals given by rank-1 arrays dl (size n ), dv (size n-1 ) and du (size n-1 ). Constructor This interface provides different methods to construct a Tridiagonal matrix. Only the non-zero elements of are\nstored, i.e. Read more… private\n\n                    pure, module\n                    function construct (dl, dv, du) Construct a Tridiagonal matrix from the rank-1 arrays dl , dv and du . private\n\n                    pure, module\n                    function construct_constant (dl, dv, du, n) Construct a Tridiagonal matrix with constant diagonal elements. private\n\n                    pure, module\n                    function initialize (n) Construct a Tridiagonal matrix filled with zeros.","tags":"","loc":"module/specialmatrices_tridiagonal.html"},{"title":"bidiagonal_constructors – SpecialMatrices","text":"Uses stdlib_linalg stdlib_optval Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_constructors.html"},{"title":"symtridiagonal_constructors – SpecialMatrices","text":"Uses stdlib_linalg stdlib_optval Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_constructors.html"},{"title":"poisson2D_utils – SpecialMatrices","text":"Uses stdlib_linalg specialmatrices_strang Ancestors: specialmatrices_poisson2D","tags":"","loc":"module/poisson2d_utils.html"},{"title":"circulant_constructors – SpecialMatrices","text":"Uses Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_constructors.html"},{"title":"toeplitz_constructors – SpecialMatrices","text":"Uses Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_constructors.html"},{"title":"bidiagonal_trace – SpecialMatrices","text":"Uses Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_trace.html"},{"title":"symtridiagonal_eigenvalue_decomposition – SpecialMatrices","text":"Uses stdlib_linalg stdlib_linalg_state stdlib_linalg_lapack Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_eigenvalue_decomposition.html"},{"title":"strang_matvecs – SpecialMatrices","text":"Uses Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_matvecs.html"},{"title":"symtridiagonal_trace – SpecialMatrices","text":"Uses Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_trace.html"},{"title":"strang_utils – SpecialMatrices","text":"Uses Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_utils.html"},{"title":"tridiagonal_matvecs – SpecialMatrices","text":"Uses stdlib_linalg_lapack Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_matvecs.html"},{"title":"diagonal_matvecs – SpecialMatrices","text":"Uses Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_matvecs.html"},{"title":"strang_determinant – SpecialMatrices","text":"Uses Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_determinant.html"},{"title":"tridiagonal_utils – SpecialMatrices","text":"Uses Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_utils.html"},{"title":"tridiagonal_determinant – SpecialMatrices","text":"Uses Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_determinant.html"},{"title":"diagonal_inverse – SpecialMatrices","text":"Uses Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_inverse.html"},{"title":"poisson2D_solve – SpecialMatrices","text":"Uses fftpack Ancestors: specialmatrices_poisson2D","tags":"","loc":"module/poisson2d_solve.html"},{"title":"diagonal_utilities – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_utilities.html"},{"title":"diagonal_determinant – SpecialMatrices","text":"Uses Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_determinant.html"},{"title":"tridiagonal_eigenvalue_decomposition – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_eigenvalue_decomposition.html"},{"title":"poisson2D_constructors – SpecialMatrices","text":"Uses stdlib_optval Ancestors: specialmatrices_poisson2D","tags":"","loc":"module/poisson2d_constructors.html"},{"title":"strang_linear_solver – SpecialMatrices","text":"Uses stdlib_linalg_state stdlib_linalg_lapack stdlib_optval Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_linear_solver.html"},{"title":"tridiagonal_singular_value_decomposition – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_singular_value_decomposition.html"},{"title":"bidiagonal_matvecs – SpecialMatrices","text":"Uses stdlib_linalg_lapack Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_matvecs.html"},{"title":"tridiagonal_linear_solver – SpecialMatrices","text":"Uses stdlib_linalg_state stdlib_linalg_lapack stdlib_optval Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_linear_solver.html"},{"title":"circulant_matvecs – SpecialMatrices","text":"Uses Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_matvecs.html"},{"title":"poisson2D_eigh – SpecialMatrices","text":"Uses stdlib_linalg stdlib_constants stdlib_sorting Ancestors: specialmatrices_poisson2D","tags":"","loc":"module/poisson2d_eigh.html"},{"title":"symtridiagonal_matvecs – SpecialMatrices","text":"Uses stdlib_linalg_lapack Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_matvecs.html"},{"title":"circulant_inverse – SpecialMatrices","text":"Uses Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_inverse.html"},{"title":"diagonal_linear_solver – SpecialMatrices","text":"Uses Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_linear_solver.html"},{"title":"bidiagonal_utils – SpecialMatrices","text":"Uses Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_utils.html"},{"title":"bidiagonal_determinant – SpecialMatrices","text":"Uses Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_determinant.html"},{"title":"diagonal_singular_value_decomposition – SpecialMatrices","text":"Uses stdlib_linalg stdlib_sorting Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_singular_value_decomposition.html"},{"title":"circulant_utilities – SpecialMatrices","text":"Uses Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_utilities.html"},{"title":"symtridiagonal_utils – SpecialMatrices","text":"Uses Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_utils.html"},{"title":"toeplitz_utilities – SpecialMatrices","text":"Uses Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_utilities.html"},{"title":"strang_constructors – SpecialMatrices","text":"Uses Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_constructors.html"},{"title":"tridiagonal_constructors – SpecialMatrices","text":"Uses Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_constructors.html"},{"title":"toeplitz_matvecs – SpecialMatrices","text":"Uses Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_matvecs.html"},{"title":"strang_eigh – SpecialMatrices","text":"Uses stdlib_constants Ancestors: specialmatrices_strang","tags":"","loc":"module/strang_eigh.html"},{"title":"symtridiagonal_determinant – SpecialMatrices","text":"Uses Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_determinant.html"},{"title":"bidiagonal_eigenvalue_decomposition – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_eigenvalue_decomposition.html"},{"title":"strange_trace – SpecialMatrices","text":"Uses Ancestors: specialmatrices_strang","tags":"","loc":"module/strange_trace.html"},{"title":"tridiagonal_trace – SpecialMatrices","text":"Uses Ancestors: specialmatrices_tridiagonal","tags":"","loc":"module/tridiagonal_trace.html"},{"title":"diagonal_constructors – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_constructors.html"},{"title":"diagonal_hermitian_eigenvalue_decomposition – SpecialMatrices","text":"Uses stdlib_linalg stdlib_sorting Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_hermitian_eigenvalue_decomposition.html"},{"title":"circulant_eigenvalue_decomposition – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_eigenvalue_decomposition.html"},{"title":"bidiagonal_singular_value_decomposition – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_singular_value_decomposition.html"},{"title":"toeplitz_eigendecomposition – SpecialMatrices","text":"Uses Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_eigendecomposition.html"},{"title":"bidiagonal_linear_solver – SpecialMatrices","text":"Uses stdlib_linalg_state stdlib_linalg_lapack Ancestors: specialmatrices_bidiagonal","tags":"","loc":"module/bidiagonal_linear_solver.html"},{"title":"diagonal_trace – SpecialMatrices","text":"Uses Ancestors: specialmatrices_diagonal","tags":"","loc":"module/diagonal_trace.html"},{"title":"symtridiagonal_singular_value_decomposition – SpecialMatrices","text":"Uses Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_singular_value_decomposition.html"},{"title":"circulant_linear_solver – SpecialMatrices","text":"Uses Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_linear_solver.html"},{"title":"symtridiagonal_linear_solver – SpecialMatrices","text":"Uses stdlib_linalg_state stdlib_linalg_lapack stdlib_optval Ancestors: specialmatrices_symtridiagonal","tags":"","loc":"module/symtridiagonal_linear_solver.html"},{"title":"toeplitz_linear_solver – SpecialMatrices","text":"Uses stdlib_linalg Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_linear_solver.html"},{"title":"circulant_svd – SpecialMatrices","text":"Uses stdlib_linalg stdlib_sorting Ancestors: specialmatrices_circulant","tags":"","loc":"module/circulant_svd.html"},{"title":"toeplitz_svd – SpecialMatrices","text":"Uses Ancestors: specialmatrices_toeplitz","tags":"","loc":"module/toeplitz_svd.html"},{"title":"poisson2D_matvecs – SpecialMatrices","text":"Uses Ancestors: specialmatrices_poisson2D","tags":"","loc":"module/poisson2d_matvecs.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_constructors use stdlib_optval , only : optval use stdlib_linalg , only : diag implicit none ( type , external ) contains module procedure initialize A % n = n ; allocate ( A % dv ( n )); allocate ( A % ev ( n - 1 )) A % dv = 0.0_dp ; A % ev = 0.0_dp ; A % which = \"L\" end procedure module procedure construct integer ( ilp ) :: n n = size ( dv ) A % n = n ; A % dv = dv ; A % ev = ev ; A % which = optval ( which , \"L\" ) end procedure module procedure construct_constant integer ( ilp ) :: i A % n = n ; A % which = optval ( which , \"L\" ) A % dv = [( d , i = 1 , n )]; A % ev = [( e , i = 1 , n - 1 )] end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90.html"},{"title":"specialmatrices_circulant.f90 – SpecialMatrices","text":"Source Code module specialmatrices_circulant use stdlib_linalg_constants , only : dp , ilp , lk use fftpack , only : fft , ifft implicit none ( type , external ) private ! --> Linear algebra public :: transpose public :: matmul public :: inv public :: solve public :: svd , svdvals public :: eig , eigvals ! --> Utility functions. public :: dense public :: shape public :: size public :: operator ( * ) !---------------------------------------------------- !-----     Base type for Circulant matrices     ----- !---------------------------------------------------- type , public :: Circulant !! Base type to define a `Circulant` matrix of size [n x n] with elements !! given by the vector c = (c[1], c[2], ..., c[n]). private integer ( ilp ) :: n !! Dimension of the matrix. real ( dp ), allocatable :: c (:) !! Generating vector. complex ( dp ), allocatable :: c_hat (:) !! Fourier Transform of the generating vector. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Circulant !! This interface provides methods to construct `Circulant` matrices. !! Given a vector  \\mathbf{c} = (c_1, c_2, \\cdots, c_n), !! the associated `Circulant` matrix is the following `[n x n]` matrix !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       c_1      &  c_2      &  \\cdots   &  c_n      \\\\ !!       c_n      &  c_1      &  \\cdots   &  \\vdots   \\\\ !!       \\vdots   &  \\ddots   &  \\ddots   &  c_2      \\\\ !!       c_2      &  \\cdots   &  c_n      &  c_1 !!    \\end{bmatrix}. !!  !! !! #### Syntax !! !! ```fortran !!    integer, parameter :: n = 100 !!    real(dp) :: c(n) !!    type(Circulant) :: A !! !!    call random_number(c) !!    A = Circulant(c) !! ``` !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function construct ( c ) result ( A ) !! Construct a `Circulant` matrix from the rank-1 array `c`. real ( dp ), intent ( in ) :: c (:) !! Generating vector. type ( Circulant ) :: A !! Corresponding Circulant matrix. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Circulant` matrix, both for matrix-vector and matrix-matrix products. !! For a matrix-matrix product  C = AB , only the matrix  A  !! has to be a `Circulant` matrix. Both  B  and  C  need to be !! standard Fortran rank-2 arrays. All the underlying functions are !! defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` pure module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product for a `Circulant` matrix A. !! Both `x` and `y` are rank-1 arrays with the same kind as `A`. type ( Circulant ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:) !! Input vector. real ( dp ), allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , X ) result ( Y ) !! Compute the matrix-matrix product for a `Circulant` matrix `A`. !! Both `X` and `Y` are rank-2 arrays with the same kind as `A`. type ( Circulant ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:, :) !! Input matrix. real ( dp ), allocatable :: y (:, :) !! Output matrix. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a !! `Circulant` matrix. It also enables to solve a linear system with !! multiple right-hand sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Circulant` type. !!          It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. !!          It has the same type and shape as `b`. !! !! @note !! Linear systems characterized by a circulant matrix can be solved !! efficiently in \\mathcal{O}(n \\log\\ n) operations using the !! Fast Fourier Transform algorithm available via `fftpack`. !! @endnote pure module function solve_single_rhs ( A , b ) result ( x ) !! Solve the linear system Ax=b where A is `Circulant` and !! `b` a standard rank-1 array. The solution vector `x` has the same !! dimension and kind as the right-hand side vector `b`. type ( Circulant ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable :: x (:) !! Solution vector. end function pure module function solve_multi_rhs ( A , B ) result ( X ) !! Solve the linear system AX=B, where `A` is `Circulant` and !! `B` is a rank-2 array. The solution matrix `X` has the same !! dimension and kind as the right-hand side matrix `B`. type ( Circulant ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: B (:, :) !! Right-hand side vectors. real ( dp ), allocatable :: X (:, :) !! Solution vectors. end function end interface interface inv pure module function inv_rdp ( A ) result ( B ) !! Utility function to compute the inverse of a `Circulant` matrix. !! If `A` is circulant, its inverse also is circulant. type ( Circulant ), intent ( in ) :: A !! Input matrix. type ( Circulant ) :: B !! Inverse of `A`. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from `stdlib_linalg` !! to compute the singular values of a `Circulant` matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Circulant` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `Circulant` matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` to !! compute the the singular value decomposition of a `Circulant` matrix !! A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s, u, vt) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Circulant` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 array `real` array returning the singular values of !!          `A`. It is an `intent(out)` argument. !! !! - `u` (optional) :   Rank-2 array of the same kind as `A` returning !!                      the left singular vectors of `A` as columns. !!                      Its size should be `[n, n]`. !!                      It is an `intent(out)` argument. !! !! - `vt` (optional) :  Rank-2 array of the same kind as `A` returning !!                      the right singular vectors of `A` as rows. Its !!                      size should be `[n, n]`. !!                      It is an `intent(out)` argument. !! !! @note !! Singular values and singular vectors of a `Circulant` matrix can be !! efficiently computed based on the Fast Fourier transform. !! @endnote module subroutine svd_rdp ( A , s , u , vt ) !! Compute the singular value decomposition of a `Circulant` matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvals !! This interface overloads the `eigvals` interface from `stdlib_linalg` !! to compute the eigenvalues of a real-valued matrix  A  whose !! type is `Circulant`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `Circulant` type. !!          It is an `intent(in)` argument. !! !! - `lambda`  :  Vector of eigenvalues in increasing order. !! !! @note !! Eigenvalues of a circulant matrix can be efficiently computed using !! the Fast Fourier Transform of the generating vector `c`. !! @endnote module function eigvals_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real `Circulant` !! matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. complex ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eig !! This interface overloads the `eig` interface from `stdlib_linalg` to !! compute the eigenvalues and eigenvectors of a real-valued matrix A !! whose type is `Circulant`. !! !! #### Syntax !! !! ```fortran !!    call eig(A, lambda [, left] [, right]) !! ``` !! !! #### Arguments !! !! - `A` : `real`-valued matrix of `Circulant`. !!          It is an `intent(in)` argument. !! !! - `lambda` :   Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! - `left` (optional)  :  `complex` rank-2 array of the same kind as !!                         `A` returning the left eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! - `right` (optional) :  `complex` rank-2 array of the same kind as !!                         `A` returning the right eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! @note !! Eigenvalues of a circulant matrix can be efficiently computed using !! the Fast Fourier Transform of the generating vector `c`. Likewise, !! its eigenvectors are simply the corresponding Fourier modes. !! @endnote module subroutine eig_rdp ( A , lambda , left , right ) !! Utility function to compute the eigenvalues and eigenvectors of a !! `Circulant` matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. complex ( dp ), intent ( out ) :: lambda (:) !! Eigenvalues. complex ( dp ), optional , intent ( out ) :: right (:, :), left (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! Convert a `Circulant` matrix to its dense representation. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Circulant` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . module function dense_rdp ( A ) result ( B ) !! Utility function to convert a `Circulant` matrix to a rank-2 array. type ( Circulant ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose operation of a `Circulant` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Circulant`. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Utility function to compute the transpose of a `Circulant` matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. type ( Circulant ) :: B !! Transpose of the matrix. end function end interface interface size !! Utility function to return the size of a `Circulant` matrix along !! a given dimension. pure module function size_rdp ( A , dim ) result ( arr_size ) !! Utility function to return the size of `Circulant` matrix along a !! given dimension. type ( Circulant ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape !! Utility function to return the shape of a `Circulant` matrix. pure module function shape_rdp ( A ) result ( arr_shape ) !! Utility function to get the shape of a `Circulant` matrix. type ( Circulant ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Circulant` matrix. real ( dp ), intent ( in ) :: alpha type ( Circulant ), intent ( in ) :: A type ( Circulant ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Circulant` matrix. type ( Circulant ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( Circulant ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_circulant.f90.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_constructors use stdlib_optval , only : optval use stdlib_linalg , only : diag implicit none ( type , external ) contains module procedure initialize A % n = n ; allocate ( A % dv ( n )); allocate ( A % ev ( n - 1 )) A % dv = 0.0_dp ; A % ev = 0.0_dp ; A % isposdef = . false . end procedure module procedure construct integer ( ilp ) :: n n = size ( dv ) A % n = n ; A % dv = dv ; A % ev = ev ; A % isposdef = optval ( isposdef , . false .) end procedure module procedure construct_constant integer ( ilp ) :: i A % n = n ; A % isposdef = optval ( isposdef , . false .) A % dv = [( d , i = 1 , n )]; A % ev = [( e , i = 1 , n - 1 )] end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~2.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_poisson2D ) poisson2D_utils use stdlib_linalg , only : eye , kron => kronecker_product use specialmatrices_strang implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: nx , ny , n real ( dp ) :: dx , dy real ( dp ), allocatable :: Idx (:, :), Idy (:, :), D2x (:, :), D2y (:, :) ! Initialize data. nx = A % nx ; ny = A % ny ; dx = A % dx ; dy = A % dy ! 1D Laplace operator in each direction. D2x = - dense ( Strang ( nx )) / dx ** 2 ; D2y = - dense ( Strang ( ny )) / dy ** 2 ! Corresponding 2D Laplace operator. Idx = eye ( nx , mold = 1.0_dp ); Idy = eye ( ny , mold = 1.0_dp ) B = kron ( Idy , D2x ) + kron ( D2y , Idx ) end procedure module procedure shape_rdp arr_shape = A % nx * A % ny end procedure module procedure size_rdp arr_size = A % nx * A % ny end procedure end submodule","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_constructors implicit none ( type , external ) contains module procedure construct integer ( ilp ) :: n !> Initialize the standard matrix data. n = size ( c ) ; A % n = n ; A % c = c !> Fourier Transform of the generating vector. A % c_hat = fft ( cmplx ( c , kind = dp ), n ) end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~3.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_constructors implicit none ( type , external ) contains module procedure construct !> Dimension of the matrix. A % m = size ( vc ) ; A % n = size ( vr ) !> First column/row vectors. A % vc = vc ; A % vr = vr !> Ensure vc[1] and vr[1] are the same. A % vr ( 1 ) = A % vc ( 1 ) end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~4.html"},{"title":"trace.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_trace implicit none ( type , external ) contains module procedure trace_rdp tr = sum ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/trace.f90.html"},{"title":"eigh.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_eigenvalue_decomposition use stdlib_linalg , only : eye use stdlib_linalg_lapack , only : steqr use stdlib_linalg_state , only : linalg_state_type , linalg_error_handling , LINALG_ERROR , & LINALG_INTERNAL_ERROR , LINALG_VALUE_ERROR , LINALG_SUCCESS implicit none ( type , external ) character ( * ), parameter :: this = \"symtridiagonal_eigenvalues\" contains ! Request for eigenvector calculation. elemental character function eigenvectors_task ( required ) logical ( lk ), intent ( in ) :: required eigenvectors_task = merge ( \"I\" , \"N\" , required ) end function eigenvectors_task ! Process STEQR output flags. elemental subroutine handle_steqr_info ( compz , n , ldz , info , err ) character , intent ( in ) :: compz integer ( ilp ), intent ( in ) :: n , ldz , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for compz=\" , compz ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for Z.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldz=\" , ldz ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for work.\" ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"steqr failed to converge.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by setqr.\" ) end select end subroutine handle_steqr_info module procedure eigh_rdp ! Local variables. type ( linalg_state_type ) :: err0 integer ( ilp ) :: n , ldz , info real ( dp ), allocatable :: work (:), dv (:), ev (:) real ( dp ), target :: vectors_dummy ( 1 , 1 ) real ( dp ), pointer :: zmat (:, :) character :: task_vectors ! Matrix size. n = A % n ! Allocate arrays. dv = A % dv ; ev = A % ev ! Should eigenvectors be computed? task_vectors = eigenvectors_task ( present ( vectors )) if ( present ( vectors )) then vectors = eye ( n ); zmat => vectors allocate ( work ( 2 * n - 2 )); ldz = n else zmat => vectors_dummy ; allocate ( work ( 1 )); ldz = 1 end if ! Compute eigenvalues and eigenvectors. call steqr ( task_vectors , n , dv , ev , zmat , ldz , work , info ) call handle_steqr_info ( task_vectors , n , n , info , err0 ) ! Return results. lambda = dv end procedure module procedure eigvalsh_rdp call eigh ( A , lambda ) end procedure end submodule symtridiagonal_eigenvalue_decomposition","tags":"","loc":"sourcefile/eigh.f90.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_matvecs implicit none ( type , external ) contains module procedure spmv integer ( ilp ) :: i , n n = A % n ; allocate ( y , mold = x ) y ( 1 ) = 2 * x ( 1 ) - x ( 2 ) do concurrent ( i = 2 : n - 1 ) y ( i ) = - x ( i - 1 ) + 2 * x ( i ) - x ( i + 1 ) end do y ( n ) = 2 * x ( n ) - x ( n - 1 ) end procedure module procedure spmvs integer ( ilp ) :: i allocate ( y , mold = x ) do concurrent ( i = 1 : size ( x , 2 )) y (:, i ) = spmv ( A , x (:, i )) end do end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90.html"},{"title":"specialmatrices_bidiagonal.f90 – SpecialMatrices","text":"Source Code module specialmatrices_bidiagonal use stdlib_linalg_constants , only : dp , ilp , lk implicit none ( type , external ) private ! --> Linear algebra public :: transpose public :: det , trace public :: matmul public :: inv public :: solve public :: svd , svdvals public :: eig , eigvals ! --> Utility functions. public :: dense public :: shape public :: size public :: operator ( * ) !----------------------------------------------------------------- !-----     Base types for Symmetric Bidiagonal matrices     ----- !----------------------------------------------------------------- type , public :: Bidiagonal !! Base type used to define a `Bidiagonal` matrix of size `[n, n]` !! with diagonals given by rank-1 arrays `dv` (size `n`) and `ev` !! (size `n-1`). private integer ( ilp ) :: n !! Dimension of the matrix. real ( dp ), allocatable :: dv (:), ev (:) !! Bidiagonal elements of the matrix. character :: which !! Whether `A` is lower- or upper-bidiagonal. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Bidiagonal !! This interface provides different methods to construct a !! `Bidiagonal` matrix. Only the non-zero elements of  A  are !! stored, i.e. !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       d_1  \\\\ !!       e_1  &  d_2   \\\\ !!             &  \\ddots   &  \\ddots   \\\\ !!             &           &  e_{n-1} &  d_{n} !!    \\end{bmatrix}. !!  !! !! if A is lower-bidiagonal or !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       d_1   &  e_1 \\\\ !!             &  \\ddots   &  \\ddots   \\\\ !!             &           &  d_{n-1}  &  e_{n-1}  \\\\ !!             &           &           &  d_n !!    \\end{bmatrix} !!  !! !! if A is upper-bidiagonal. !! !! @warning !! By default, the matrix is lower-bidiagonal. To create an upper- !! bidiagonal, set `A%which = \"U\"`. !! @endwarning !! !! #### Syntax !! !! - Construct a `Bidiagonal` matrix filled with zeros: !! !! ```fortran !!    integer, parameter :: n = 100 !!    type(Bidiagonal) :: A !! !!    A = Bidiagonal(n) !! ``` !! !! - Construct a `Bidiagonal` matrix from rank-1 arrays: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), allocatable :: ev(:), dv(:) !!    type(Bidiagonal) :: A !!    integer :: i !! !!    dv = [(i, i=1, n)]; ev = [(2*i, i=1, n)] !!    A = Bidiagonal(dv, ev) !! ``` !! !! - Construct a `Bidiagonal` matrix with constant diagonals: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), parameter :: d = 1.0_dp, e = 2.0_dp !!    type(Bidiagonal) :: A !! !!    A = Bidiagonal(d, e, n) !! ``` !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function initialize ( n ) result ( A ) !! Construct a `Bidiagonal` matrix filled with zeros. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Bidiagonal ) :: A !! Symmetric Bidiagonal matrix. end function pure module function construct ( dv , ev , which ) result ( A ) !! Construct a `Bidiagonal` matrix from the rank-1 arrays `dv` !! and `ev`. real ( dp ), intent ( in ) :: dv (:), ev (:) !! Bidiagonal elements of the matrix. character , optional , intent ( in ) :: which !! Whether `A` is lower- or upper-diagonal. type ( Bidiagonal ) :: A !! Bidiagonal matrix. end function pure module function construct_constant ( d , e , n , which ) result ( A ) !! Construct a `Bidiagonal` matrix with constant diagonal elements. real ( dp ), intent ( in ) :: d , e !! Bidiagonal elements of the matrix. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. character , optional , intent ( in ) :: which !! Whether `A` is lower- or upper-bidiagonal. type ( Bidiagonal ) :: A !! Symmetric Bidiagonal matrix. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Bidiagonal` matrix, both for matrix-vector and matrix-matrix !! products. For a matrix-matrix product  C = AB , only the matrix !!  A  has to be a `Bidiagonal` matrix. Both  B  and  C  !! need to be standard Fortran rank-2 arrays. All the underlying !! functions are defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product y = Ax for a `Bidiagonal` !! matrix A. Both `x` and `y` are rank-1 arrays with the same !! kind as `A`. type ( Bidiagonal ), target , intent ( in ) :: A !! Input matrix. real ( dp ), target , intent ( in ) :: x (:) !! Input vector. real ( dp ), target , allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , X ) result ( Y ) !! Compute the matrix-matrix product Y = Ax for a `Bidiagonal` !! matrix A and a dense matrix X (rank-2 array). Y is !! also a rank-2 array with the same dimensions as X. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: X (:, :) !! Input vectors. real ( dp ), allocatable :: Y (:, :) !! Output vectors. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a !! `Bidiagonal` matrix. It also enables to solve a linear system with !! multiple right-hand sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. !!          It has the same type and shape as `b`. pure module function solve_single_rhs ( A , b ) result ( x ) !! Solve the linear system Ax=b where A is of type !! `Bidiagonal` and `b` a standard rank-1 array. The solution !! vector `x` has the same dimension and kind as `b`. type ( Bidiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable , target :: x (:) !! Solution vector. end function pure module function solve_multi_rhs ( A , b ) result ( x ) !! Solve the linear system AX=B where A is of type !! `Bidiagonal` and `B` a standard rank-2 array. The solution matrix !! `X` has the same dimensions and kind as `B`. type ( Bidiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. real ( dp ), allocatable , target :: x (:, :) !! Solution vectors. end function end interface interface inv pure module function inv_rdp ( A ) result ( B ) !! Utility function to compute the inverse of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: B (:, :) !! Inverse of `A`. end function end interface !----------------------------------------- !-----     Determinant and Trace     ----- !----------------------------------------- interface det !! This interface overloads the `det` interface from `stdlib_linag` to !! compute the determinant \\det(A) where A is of type !! `Bidiagonal`. !! !! #### Syntax !! !! ```fortran !!    d = det(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is in an `intent(in)` argument. !! !! - `d` :  Determinant of the matrix. pure module function det_rdp ( A ) result ( d ) !! Compute the determinant of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: d !! Determinant of the matrix. end function end interface interface trace !! This interface overloads the `trace` interface from `stdlib_linalg` !! to compute the trace of a matrix  A  of type `Bidiagonal`. !! !! #### Syntax !! !! ```fortran !!    tr = trace(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `tr`:  Trace of the matrix. pure module function trace_rdp ( A ) result ( tr ) !! Compute the trace of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: tr !! Trace of the matrix. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from !! `stdlib_linalg` to compute the singular values of a `Bidiagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` !! to compute the the singular value decomposition of a `Bidiagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s [, u] [, vt]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 array `real` array returning the singular values of !!          `A`. It is an `intent(out)` argument. !! !! - `u` (optional) :   Rank-2 array of the same kind as `A` returning !!                      the left singular vectors of `A` as columns. !!                      Its size should be `[n, n]`. It is an !!                      `intent(out)` argument. !! !! - `vt` (optional):   Rank-2 array of the same kind as `A` returning !!                      the right singular vectors of `A` as rows. !!                      Its size should be `[n, n]`. It is an !!                      `intent(out)` argument. module subroutine svd_rdp ( A , s , u , vt ) !! Compute the singular value decomposition of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvals !! This interface overloads the `eigvalsh` interface from !! `stdlib_linalg` to compute the eigenvalues of a real-valued matrix !!  A  whose type is `Bidiagonal`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `lambda` :  Vector of eigenvalues in increasing order. module function eigvals_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real !! `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. complex ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eig !! This interface overloads the `eigh` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of a real-valued matrix !! A whose type is `Bidiagonal`. !! !! #### Syntax !! !! ```fortran !!    call eig(A, lambda [, left] [, right]) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `Bidiagonal`. !!          It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! - `left` (optional)  :  `complex` rank-2 array of the same kind as !!                         `A` returning the left eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! - `right` (optional) :  `complex` rank-2 array of the same kind as !!                         `A` returning the right eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! @note !! No specialized eigensolvers for generic `Bidiagonal` matrices exist !! in LAPACK. This routine thus falls back to wrapping the `eig` !! procedure from `stdlib_linalg` which uses `*geev` under the hood. !! @endnote module subroutine eig_rdp ( A , lambda , left , right ) !! Utility function to compute the eigenvalues and eigenvectors of a !! `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. complex ( dp ), intent ( out ) :: lambda (:) !! Eigenvalues. complex ( dp ), optional , intent ( out ) :: right (:, :), left (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! This interface provides methods to convert a `Bidiagonal` matrix !! to a regular rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . module function dense_rdp ( A ) result ( B ) !! Utility function to convert a `Bidiagonal` matrix to a !! rank-2 array. type ( Bidiagonal ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose of a `Bidiagonal` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Bidiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Utility function to compute the transpose of a `Bidiagonal` !! matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. type ( Bidiagonal ) :: B !! Transpose of the matrix. end function end interface interface size pure module function size_rdp ( A , dim ) result ( arr_size ) !! Utility function to return the size of `Bidiagonal` matrix along !! a given dimension. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape pure module function shape_rdp ( A ) result ( arr_shape ) !! Utility function to get the shape of a `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Bidiagonal` matrix. real ( dp ), intent ( in ) :: alpha type ( Bidiagonal ), intent ( in ) :: A type ( Bidiagonal ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Bidiagonal` matrix. type ( Bidiagonal ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( Bidiagonal ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_bidiagonal.f90.html"},{"title":"trace.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_trace implicit none ( type , external ) contains module procedure trace_rdp tr = sum ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/trace.f90~2.html"},{"title":"inv.f90 – SpecialMatrices","text":"Source Code","tags":"","loc":"sourcefile/inv.f90.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_utils implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: i , n n = A % n allocate ( B ( n , n )); B = 0.0_dp B ( 1 , 1 ) = 2 ; B ( 1 , 2 ) = - 1 do concurrent ( i = 2 : A % n - 1 ) B ( i , i - 1 ) = - 1 ; B ( i , i ) = 2 ; B ( i , i + 1 ) = - 1 end do B ( n , n - 1 ) = - 1 ; B ( n , n ) = 2 end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure size_rdp arr_size = A % n end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~2.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_matvecs use stdlib_linalg_lapack , only : lagtm implicit none ( type , external ) contains module procedure spmv ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp real ( dp ), pointer :: xmat (:, :), ymat (:, :) ! Setup variables. n = A % n ; nrhs = 1 ; ldx = n ; ldy = n ; trans = \"N\" y = x ; xmat ( 1 : n , 1 : nrhs ) => x ; ymat ( 1 : n , 1 : nrhs ) => y ! Matrix-vector product. call lagtm ( trans , n , nrhs , alpha , A % dl , A % dv , A % du , xmat , ldx , beta , ymat , ldy ) end procedure module procedure spmvs ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp ! Setup variables. n = A % n ; nrhs = size ( x , 2 ); ldx = n ; ldy = n ; trans = \"N\" ; y = x ! Matrix-vector product. call lagtm ( trans , n , nrhs , alpha , A % dl , A % dv , A % du , x , ldx , beta , y , ldy ) end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~2.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_matvecs implicit none ( type , external ) contains module procedure spmv ! Utility function to compute the matrix-vector product. integer ( ilp ) :: i allocate ( y , mold = x ) do concurrent ( i = 1 : size ( x )) y ( i ) = A % dv ( i ) * x ( i ) end do end procedure module procedure spmvs ! Utility function to compute multiple matrix-vector products. integer ( ilp ) :: i , j allocate ( y , mold = x ) do concurrent ( i = 1 : size ( x , 1 ), j = 1 : size ( x , 2 )) y ( i , j ) = A % dv ( i ) * x ( i , j ) end do end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~3.html"},{"title":"det.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_determinant implicit none ( type , external ) contains module procedure det_rdp d = A % n + 1 end procedure end submodule","tags":"","loc":"sourcefile/det.f90.html"},{"title":"specialmatrices_toeplitz.f90 – SpecialMatrices","text":"Source Code module specialmatrices_toeplitz use stdlib_linalg_constants , only : dp , ilp , lk use stdlib_linalg , only : eig , eigvals , svd , svdvals use specialmatrices_circulant implicit none ( type , external ) private ! --> Linear algebra public :: transpose public :: matmul public :: solve public :: svd , svdvals public :: eig , eigvals ! --> Utility functions. public :: Circulant public :: dense public :: shape public :: size public :: operator ( * ) !--------------------------------------------------- !-----     Base type for Toeplitz matrices     ----- !--------------------------------------------------- type , public :: Toeplitz !! Base type to define a `Toeplitz` matrix of size [m x n]. The first !! column is given by the vector `vc` while the first row is given by !! `vr`. private integer ( ilp ) :: m , n !! Dimensions of the matrix. real ( dp ), allocatable :: vc (:) !! First column of the matrix. real ( dp ), allocatable :: vr (:) !! First row of the matrix. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Toeplitz !! This interface provides methods to construct `Toeplitz` matrices. !! Given a vector `vc` specifying the first column of the matrix and a !! vector `vr` specifying its first row, the associated `Toeplitz` !! matrix is the following m \\times n matrix !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       t_0      &  t_{-1}      &  \\cdots   &  t_{-(n-1)}      \\\\ !!       t_1      &  t_0      &  \\cdots   &  \\vdots   \\\\ !!       \\vdots   &  \\ddots   &  \\ddots   &  t_{-1}      \\\\ !!       t_{m-1}      &  \\cdots   &  t_1      &  t_0 !!    \\end{bmatrix}. !!  !! !! #### Syntax !! !! ```fortran !!    integer, parameter :: m = 100, n = 200 !!    real(dp) :: vc(n), vr(n) !!    type(Toeplitz) :: A !! !!    call random_number(vc) ; call random_number(vr) !!    A = Toeplitz(vc, vr) !! ``` !! !! @warning !! The element  A_{11}  is read from the first entry of the vector !! `vc`. The first entry of `vr` is not referenced. !! @endwarning !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function construct ( vc , vr ) result ( A ) !! Construct a `Toeplitz` matrix from the rank-1 arrays `vc` and `vr`. real ( dp ), intent ( in ) :: vc (:) !! First column of the matrix. real ( dp ), intent ( in ) :: vr (:) !! First row of the matrix. type ( Toeplitz ) :: A !! Corresponding Toeplitz matrix. end function end interface interface Circulant !! Utility function to embed an m x n `Toeplitz` matrix into an !! (m+n) x (m+n) `Circulant` matrix. pure module function Toeplitz2Circulant ( T ) result ( C ) type ( Toeplitz ), intent ( in ) :: T type ( Circulant ) :: C end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Toeplitz` matrix, both for matrix-vector and matrix-matrix products. !! For a matrix-matrix product  C = AB , only the matrix  A  !! has to be a `Toeplitz` matrix. Both  B  and  C  need to be !! standard Fortran rank-2 arrays. All the underlying functions are !! defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` !! !! @note !! Matrix-vector products for `Toeplitz` matrices can be efficiently !! computed by embedding the `Toeplitz` matrix into a `Circulant` matrix !! of size `[m+n x m+n]` and using the Fast Fourier Transform provided !! by `fftpack`. !! @endnote pure module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product for a `Toeplitz` matrix A. !! Both `x` and `y` are rank-1 arrays with the same kind as `A`. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:) !! Input vector. real ( dp ), allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , X ) result ( Y ) !! Compute the matrix-matrix product for a `Toeplitz` matrix `A`. !! Both `X` and `Y` are rank-2 arrays with the same kind as `A`. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:, :) !! Input matrix. real ( dp ), allocatable :: y (:, :) !! Output matrix. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a `Toeplitz` !! matrix. It also enables to solve a linear system with multiple !! right-hand sides. !! !! #### Syntax !! !! To solve a system with  A  being of type `Toeplitz`: !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. !!          It has the same type and shape as `b`. !! !! @note !! Under the hood, a `gmres` solver is being used along with a !! Circulant preconditioner. By design, `gmres` is run until a !! relative tolerance of 10&#94;{-8} is reached. !! @endnote pure module function solve_single_rhs ( A , b ) result ( x ) !! Solve the linear system Ax=b where A is `Toeplitz` and `b` !! a standard rank-1 array. The solution vector `x` has the same !! dimension and kind as the right-hand side vector `b`. type ( Toeplitz ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable :: x (:) !! Solution vector. end function pure module function solve_multi_rhs ( A , B ) result ( X ) !! Solve the linear system AX=B, where `A` is `Toeplitz` and `B` !! is a rank-2 array. The solution matrix `X` has the same dimension !! and kind as the right-hand side matrix `B`. type ( Toeplitz ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: B (:, :) !! Right-hand side vectors. real ( dp ), allocatable :: X (:, :) !! Solution vectors. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from `stdlib_linalg` !! to compute the singular values of a `Toeplitz` matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. !! !! @note !! No analytic expression exist for the singular values of a general !! `Toeplitz` matrix. Under the hood, the matrix `A` is converted to !! its dense representation and the function `svdvals` from !! `stdlib_linalg` is used. !! @endnote module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` to !! compute the the singular value decomposition of a `Toeplitz` matrix !! A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s, u, vt) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 array `real` array returning the singular values of !!          `A`. It is an `intent(out)` argument. !! !! - `u` (optional)  :  Rank-2 array of the same kind as `A` returning !!                      the left singular vectors of `A` as columns. Its !!                      size should be `[n, n]`. !!                      It is an `intent(out)` argument. !! !! - `vt` (optional) :  Rank-2 array of the same kind as `A` returning !!                      the right singular vectors of `A` as rows. Its !!                      size should be `[n, n]`. It is an `intent(out)` !!                      argument. !! !! @note !! No analytic expression exist for the singular value of a general !! `Toeplitz` matrix. Under the hood, the matrix `A` is converted to !! its dense representation and the function `svdvals` from !! `stdlib_linalg` is used. !! @endnote module subroutine svd_rdp ( A , s , u , vt ) !! Compute the singular value decomposition of a `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvals !! This interface overloads the `eigvals` interface from `stdlib_linalg` !! to compute the eigenvalues of a real-valued matrix  A  whose !! type is `Toeplitz`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `lambda` :  Vector of eigenvalues in increasing order. !! !! @note !! No analytic expression exist for the eigenvalues of a general !! `Toeplitz` matrix. Under the hood, the matrix `A` is converted to !! its dense representation and the function `eigvals` from !! `stdlib_linalg` is used. !! @endnote module function eigvals_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real `Toeplitz` !! matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. complex ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eig !! This interface overloads the `eig` interface from `stdlib_linalg` to !! compute the eigenvalues and eigenvectors of a real-valued matrix !! A whose type is `Toeplitz`. !! !! #### Syntax !! !! ```fortran !!    call eig(A, lambda [, left] [, right]) !! ``` !! !! #### Arguments !! !! - `A` : `real`-valued matrix of `Toeplitz`. !!          It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. !!                It is an `intent(out)` argument. !! !! - `left` (optional) :  `complex` rank-2 array of the same kind as `A` !!                         returning the left eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! - `right` (optional) : `complex` rank-2 array of the same kind as `A` !!                         returning the right eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! @note !! No analytic expression exist for the eigendecomposition of a general !! `Toeplitz` matrix. Under the hood, the matrix `A` is converted to !! its dense representation and the function `eig` from !! `stdlib_linalg` is used. !! @endnote module subroutine eig_rdp ( A , lambda , left , right ) !! Utility function to compute the eigenvalues and eigenvectors of a !! `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. complex ( dp ), intent ( out ) :: lambda (:) !! Eigenvalues. complex ( dp ), optional , intent ( out ) :: right (:, :), left (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! Convert a `Toeplitz` matrix to a standard rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . pure module function dense_rdp ( A ) result ( B ) !! Utility function to convert a `Toeplitz` matrix to a rank-2 array. type ( Toeplitz ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose operation of a `Toeplitz` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Toeplitz` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Utility function to compute the transpose of a `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. type ( Toeplitz ) :: B !! Transpose of the matrix. end function end interface interface size !! Utility function to return the size of `Toeplitz` matrix along a !! given dimension. pure module function size_rdp ( A , dim ) result ( arr_size ) type ( Toeplitz ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape !! Utility function to return the size of a `Toeplitz` matrix. pure module function shape_rdp ( A ) result ( arr_shape ) !! Utility function to get the shape of a `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Utility function to perform a scalar multiplication with a `Toeplitz` matrix. real ( dp ), intent ( in ) :: alpha type ( Toeplitz ), intent ( in ) :: A type ( Toeplitz ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Utility function to perform a scalar multiplication with a `Toeplitz` matrix. type ( Toeplitz ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( Toeplitz ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_toeplitz.f90.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_utils implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: i , n n = A % n ; allocate ( B ( n , n )); B = 0.0_dp B ( 1 , 1 ) = A % dv ( 1 ); B ( 1 , 2 ) = A % du ( 1 ) do concurrent ( i = 2 : n - 1 ) B ( i , i - 1 ) = A % dl ( i - 1 ) B ( i , i ) = A % dv ( i ) B ( i , i + 1 ) = A % du ( i ) end do B ( n , n - 1 ) = A % dl ( n - 1 ); B ( n , n ) = A % dv ( n ) end procedure module procedure transpose_rdp B = A end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure size_rdp arr_size = A % n end procedure module procedure scalar_multiplication_rdp B = Tridiagonal ( alpha * A % dl , alpha * A % dv , alpha * A % du ) end procedure module procedure scalar_multiplication_bis_rdp B = Tridiagonal ( alpha * A % dl , alpha * A % dv , alpha * A % du ) end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~3.html"},{"title":"det.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_determinant implicit none ( type , external ) contains module procedure det_rdp real ( dp ) :: f_0 , f_1 integer ( ilp ) :: i f_0 = 1.0_dp ; f_1 = 0.0_dp ! First iteration. d = A % dv ( 1 ) * f_0 ; f_1 = f_0 ; f_0 = d ! Continuants do i = 2 , A % n ! Reccurence relation. d = A % dv ( i ) * f_0 - A % dl ( i - 1 ) * A % du ( i - 1 ) * f_1 ! Store previous values. f_1 = f_0 ; f_0 = d end do end procedure end submodule","tags":"","loc":"sourcefile/det.f90~2.html"},{"title":"inv.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_inverse implicit none ( type , external ) contains module procedure inv_rdp B = Diagonal ( 1.0_dp / A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/inv.f90~2.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_poisson2D ) poisson2D_solve use fftpack , only : dst => dsint , init_dst => dsinti implicit none ( type , external ) character ( len =* ), parameter :: this = \"poisson2D_linear_solver\" contains module procedure solve_single_rhs ! Local variables. integer ( ilp ) :: nx , ny , i , j , nx_wrk , ny_wrk real ( dp ), allocatable :: lambda_x (:), lambda_y (:) real ( dp ), allocatable :: wsave_x (:), wsave_y (:) real ( dp ), pointer :: xmat (:, :) real ( dp ) :: scale ! Initializes pointer and allocatable arrays. nx = A % nx ; ny = A % ny x = b ; xmat ( 1 : nx , 1 : ny ) => x nx_wrk = int ( 2.5 * nx + 15 , kind = ilp ) ; ny_wrk = int ( 2.5 * ny + 15 , kind = ilp ) allocate ( wsave_x ( nx_wrk )) ; allocate ( wsave_y ( ny_wrk )) ! Initializes Discrete Sine Transforms (Type-I). call init_dst ( nx , wsave_x ) ; call init_dst ( ny , wsave_y ) ! Compute the DST-I of the right-hand side. do concurrent ( j = 1 : ny ) call dst ( nx , xmat (:, j ), wsave_x ) enddo do concurrent ( i = 1 : nx ) call dst ( ny , xmat ( i , :), wsave_y ) enddo ! Compute the eigenvalues of the 1D Laplacian operators. lambda_x = - eigvalsh ( Strang ( nx )) / A % dx ** 2 lambda_y = - eigvalsh ( Strang ( ny )) / A % dy ** 2 ! Compute the solution in spectral space. do concurrent ( i = 1 : nx , j = 1 : ny ) xmat ( i , j ) = xmat ( i , j ) / ( lambda_x ( i ) + lambda_y ( j )) enddo ! Inverse DST-I of the solution. scale = 1.0_dp / ( 2 * ( nx + 1 ) * 2 * ( ny + 1 )) do concurrent ( j = 1 : ny ) call dst ( nx , xmat (:, j ), wsave_x ) enddo do concurrent ( i = 1 : nx ) call dst ( ny , xmat ( i , :), wsave_y ) enddo xmat = scale * xmat end procedure module procedure solve_multi_rhs integer ( ilp ) :: i allocate ( x , mold = b ) do concurrent ( i = 1 : size ( b , 2 )) x (:, i ) = solve ( A , b (:, i )) enddo end procedure end submodule","tags":"","loc":"sourcefile/solve.f90.html"},{"title":"specialmatrices_symtridiagonal.f90 – SpecialMatrices","text":"Source Code module specialmatrices_symtridiagonal use stdlib_linalg_constants , only : dp , ilp , lk implicit none ( type , external ) private ! --> Linear algebra public :: transpose public :: det , trace public :: matmul public :: inv public :: solve public :: svd , svdvals public :: eigh , eigvalsh ! --> Utility functions. public :: dense public :: shape public :: size public :: operator ( * ) !----------------------------------------------------------------- !-----     Base types for Symmetric Tridiagonal matrices     ----- !----------------------------------------------------------------- type , public :: SymTridiagonal !! Base type used to define a `SymTridiagonal` matrix of size `[n, n]` !! with diagonals given by rank-1 arrays `dv` (size `n`) and `ev` !! (size `n-1`). private integer ( ilp ) :: n !! Dimension of the matrix. real ( dp ), allocatable :: dv (:), ev (:) !! SymTridiagonal elements of the matrix. logical ( lk ) :: isposdef end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface SymTridiagonal !! This interface provides different methods to construct a !! `SymTridiagonal` matrix. Only the non-zero elements of  A  are !! stored, i.e. !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       d_1   &  e_1  \\\\ !!       e_1  &  d_2      &  e_2  \\\\ !!             &  \\ddots   &  \\ddots   &  \\ddots   \\\\ !!             &           &  e_{n-2} &  d_{n-1}  &  e_{n-1} \\\\ !!             &           &           &  e_{n-1} &  d_n !!    \\end{bmatrix}. !!  !! !! #### Syntax !! !! - Construct a `SymTridiagonal` matrix filled with zeros: !! !! ```fortran !!    integer, parameter :: n = 100 !!    type(SymTridiagonal) :: A !! !!    A = SymTridiagonal(n) !! ``` !! !! - Construct a `SymTridiagonal` matrix from rank-1 arrays: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), allocatable :: ev(:), dv(:) !!    type(SymTridiagonal) :: A !!    integer :: i !! !!    dv = [(i, i=1, n)]; ev = [(2*i, i=1, n)] !!    A = Tridiagonal(dv, ev) !! ``` !! !! - Construct a `SymTridiagonal` matrix with constant diagonals: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), parameter :: d = 1.0_dp, e = 2.0_dp !!    type(SymTridiagonal) :: A !! !!    A = SymTridiagonal(d, e, n) !! ``` !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote !! !! @note !! If  A  is known to be symmetric positive definite, it can be !! constructed as `A = SymTridiagonal(dv, ev, ifposdef=.true.)`:w !! @endnote pure module function initialize ( n ) result ( A ) !! Construct a `SymTridiagonal` matrix filled with zeros. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( SymTridiagonal ) :: A !! Symmetric Tridiagonal matrix. end function pure module function construct ( dv , ev , isposdef ) result ( A ) !! Construct a `SymTridiagonal` matrix from the rank-1 arrays !! `dv` and `ev`. real ( dp ), intent ( in ) :: dv (:), ev (:) !! SymTridiagonal elements of the matrix. logical ( lk ), optional , intent ( in ) :: isposdef !! Whether `A` is positive-definite or not. type ( SymTridiagonal ) :: A !! Symmetric Tridiagonal matrix. end function pure module function construct_constant ( d , e , n , isposdef ) result ( A ) !! Construct a `SymTridiagonal` matrix with constant diagonal !! elements. real ( dp ), intent ( in ) :: d , e !! SymTridiagonal elements of the matrix. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. logical ( lk ), optional , intent ( in ) :: isposdef !! Whether `A` is positive-definite or not. type ( SymTridiagonal ) :: A !! Symmetric Tridiagonal matrix. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `SymTridiagonal` matrix, both for matrix-vector and matrix-matrix !! products. For a matrix-matrix product  C = AB , only the matrix !!  A  has to be a `SymTridiagonal` matrix. Both  B  and  C  !! need to be standard Fortran rank-2 arrays. All the underlying !! functions are defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product y = Ax for a `SymTridiagonal` !! matrix A. Both `x` and `y` are rank-1 arrays with the same !! kind as `A`. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), target , intent ( in ) :: x (:) !! Input vector. real ( dp ), target , allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , x ) result ( y ) !! Compute the matrix-matrix product Y = Ax for a `SymTridiagonal` !! matrix A and a dense matrix X (rank-2 array). Y is !! also a rank-2 array with the same dimensions as X. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: X (:, :) !! Input vectors. real ( dp ), allocatable :: Y (:, :) !! Output vectors. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a !! `SymTridiagonal` matrix. It also enables to solve a linear system !! with multiple right-hand sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b [, refine]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `refine` (optional) : Logical switch to enable solution refinement. !! !! - `x` :  Solution of the linear system. !!          It has the same type and shape as `b`. module function solve_single_rhs ( A , b , refine ) result ( x ) !! Solve the linear system Ax=b where A is of type !! `SymTridiagonal` and `b` a standard rank-1 array. The solution !! vector `x` has the same dimension and kind as `b`. type ( SymTridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), target , intent ( in ) :: b (:) !! Right-hand side vector. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refinement of the solution is used or not. real ( dp ), allocatable , target :: x (:) !! Solution vector. end function module function solve_multi_rhs ( A , b , refine ) result ( x ) !! Solve the linear system AX=B where A is of type !! `SymTridiagonal` and `B` a standard rank-2 array. The solution !! matrix `X` has the same dimensions and kind as `B`. type ( SymTridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refinement of the solution is used or not. real ( dp ), allocatable :: x (:, :) !! Solution vectors. end function end interface interface inv pure module function inv_rdp ( A ) result ( B ) !! Compute the inverse of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: B (:, :) !! Inverse of `A`. end function end interface !----------------------------------------- !-----     Determinant and Trace     ----- !----------------------------------------- interface det !! This interface overloads the `det` interface from `stdlib_linag` to !! compute the determinant \\det(A) where A is of type !! `SymTridiagonal`. !! !! #### Syntax !! !! ```fortran !!    d = det(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is in an `intent(in)` argument. !! !! - `d` :  Determinant of the matrix. pure module function det_rdp ( A ) result ( d ) !! Compute the determinant of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: d !! Determinant of the matrix. end function end interface interface trace !! This interface overloads the `trace` interface from `stdlib_linalg` !! to compute the trace of a matrix  A  of type `SymTridiagonal`. !! !! #### Syntax !! !! ```fortran !!    tr = trace(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `tr`:  Trace of the matrix. pure module function trace_rdp ( A ) result ( tr ) !! Compute the trace of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: tr !! Trace of the matrix. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from `stdlib_linalg` !! to compute the singular values of a `SymTridiagonal` matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` to !! compute the the singular value decomposition of a `SymTridiagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s [, u] [, vt]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 array `real` array returning the singular values of !!          `A`. It is an `intent(out)` argument. !! !! - `u` (optional)  :  Rank-2 array of the same kind as `A` returning !!                      the left singular vectors of `A` as columns. Its !!                      size should be `[n, n]`. !!                      It is an `intent(out)` argument. !! !! - `vt` (optional) :  Rank-2 array of the same kind as `A` returning !!                      the right singular vectors of `A` as rows. Its !!                      size should be `[n, n]`. !!                      It is an `intent(out)` argument. module subroutine svd_rdp ( A , s , u , vt ) !! Compute the singular value decomposition of a `SymTridiagonal` !! matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), allocatable , optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), allocatable , optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvalsh !! This interface overloads the `eigvalsh` interface from !! `stdlib_linalg` to compute the eigenvalues of a matrix  A  whose !! type is `SymTridiagonal`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvalsh(A) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `lambda` :  Vector of eigenvalues in increasing order. module function eigvalsh_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real !! `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eigh !! This interface overloads the `eigh` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of a matrix A whose !! type is `SymTridiagonal`. !! !! #### Syntax !! !! ```fortran !!    call eigh(A, lambda [, vectors]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal`. !!          It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! - `vectors` (optional)  :  Rank-2 array of the same kind as `A` !!                            returning the eigenvectors of `A`. !!                            It is an `intent(out)` argument. module subroutine eigh_rdp ( A , lambda , vectors ) !! Compute the eigenvalues and eigenvectors of a `SymTridiagonal` !! matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ) :: lambda (:) !! Eigenvalues. real ( dp ), allocatable , optional , target , intent ( out ) :: vectors (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! This interface provides methods to convert a `SymTridiagonal` matrix !! to a regular rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . module function dense_rdp ( A ) result ( B ) !! Convert a `SymTridiagonal` matrix to a rank-2 array. type ( SymTridiagonal ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose operation for a `SymTridiagonal` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `SymTridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Compute the transpose of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. type ( SymTridiagonal ) :: B !! Transpose of the matrix. end function end interface interface size pure module function size_rdp ( A , dim ) result ( arr_size ) !! Return the size of `SymTridiagonal` matrix along a given !! dimension. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape pure module function shape_rdp ( A ) result ( arr_shape ) !! Return the shape of a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Scalar multiplication with a `SymTridiagonal` matrix. real ( dp ), intent ( in ) :: alpha type ( SymTridiagonal ), intent ( in ) :: A type ( SymTridiagonal ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Scalar multiplication with a `SymTridiagonal` matrix. type ( SymTridiagonal ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( SymTridiagonal ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_symtridiagonal.f90.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_utilities use stdlib_linalg , only : diag implicit none ( type , external ) contains module procedure dense_rdp B = diag ( A % dv ) end procedure module procedure transpose_rdp B = A end procedure module procedure size_rdp arr_size = A % n end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure scalar_multiplication_rdp B = Diagonal ( alpha * A % dv ) end procedure module procedure scalar_multiplication_bis_rdp B = Diagonal ( alpha * A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~4.html"},{"title":"specialmatrices_poisson2D.f90 – SpecialMatrices","text":"Source Code module specialmatrices_poisson2D use stdlib_linalg_constants , only : dp , ilp , lk use specialmatrices_strang , only : Strang , dense , eigvalsh , eigh implicit none ( type , external ) private public :: Poisson2D ! --> Linear algebra. public :: matmul public :: solve public :: eigh , eigvalsh ! --> Utility functions. public :: dense public :: shape public :: size !------------------------------------------------------ !-----     Base type for the Poisson2D matrix     ----- !------------------------------------------------------ type :: Poisson2D !! Base type used to define a `Poisson2D` matrix on a rectangular domain !! discretized with `nx` and `ny` points in each direction and !! corresponding grid spacings `dx` and `dy`. private integer ( ilp ) :: nx , ny !! Dimension of the grid in each direction. real ( dp ) :: dx , dy !! Grid spacing in each direction. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Poisson2D !! Constructor for generating a `Poisson2D` matrix. The matrix corresponds !! to the standard second-order accurate finite-difference approximation !! of the Laplace operator with homogeneous Dirichlet boundary conditions. !! !! #### Syntax !! !! - Construct the finite-difference approximation of the Laplace operator !!    on the rectangular domain \\Omega = \\left[ 0, 1 \\right] \\times \\left[ 0, 2 \\right] !!    using 128 points in the horizontal direction and 256 in the !!    vertical one. !! !! ```fortran !!    type(Poisson2D)     :: A !!    integer, parameter  :: nx = 128, ny = 256 !!    real(dp), parameter :: Lx = 1.0_dp, Ly = 2.0_dp !! !!    A = Poisson2D(nx, ny, Lx, Ly) !! ``` !! !! @note !! Only `doube precision` is currently supported for this matrix type. !! @endnote !! !! @note !! Note that `Lx` and `Ly` are optional. If not specified, they default !! to `1.0_dp`. !! @endnote pure module function initialize ( nx , ny , Lx , Ly ) result ( A ) !! Utility function to construct a `Poisson2D` matrix. integer ( ilp ), intent ( in ) :: nx , ny !! Number of grid points in each direction. real ( dp ), optional , intent ( in ) :: Lx , Ly !! Physical extent of each dimension. type ( Poisson2D ) :: A !! Corresponding Poisson2D matrix. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Poisson2D` matrixn, both for matrix-vector and matrix-matrix !! products. For a matrix-matrix product C = AB, only the matrix !!  A  has to be a `Poisson2D` matrix. Both  B  and  C  are !! standard Fortran rank-2 arrays. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product y = Ax for a `Poisson2D` matrix  A . !! Both `x` and `y` are rank-1 arrays with the same kind as `A`. type ( Poisson2D ), intent ( in ) :: A !! Input matrix. real ( dp ), target , intent ( in ) :: x (:) !! Input vector. real ( dp ), allocatable , target :: y (:) !! Output vector. end function module function spmvs ( A , x ) result ( y ) !! Compute the matrix-matrix product Y=AX for a `Poisson2D` matrix  A . !! X and Y are rank-2 arrays of appropriate size with the same kind as A. type ( Poisson2D ), intent ( in ) :: A !! Input matrix. real ( dp ), target , contiguous , intent ( in ) :: x (:, :) !! Input vectors. real ( dp ), allocatable , target :: y (:, :) !! Output vectors. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a system Ax = b where A is a `Poisson2D` matrix. !! It also enables to solve a linear system with multiple right-hand !! sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of type `Poisson2D`. It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. It has the same type and !!          shape as `b`. !! !! @note !! It uses a fast Poisson solver leveraging the discrete sine !! transform provided by `fftpack`. Only homogeneous Dirichlet boundary !! conditions are handled by default. If non-homogeneous Dirichlet !! boundary conditions need to be used, they can be implemented by !! modifiying the right-hand side vector. Neuman-type boundary !! conditions are not supported at all. !! @endnote pure module function solve_single_rhs ( A , b ) result ( x ) !! Solve the linear system Ax = b using a fast Poisson solver. type ( Poisson2D ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable , target :: x (:) !! Solution vector. end function pure module function solve_multi_rhs ( A , b ) result ( x ) !! Solve the linear system AX=B using a fast Poisson solver. type ( Poisson2D ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. real ( dp ), allocatable , target :: x (:, :) !! Solution vectors. end function end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvalsh !! This interface overloads the `eigvalsh` interface from `stdlib_linalg` !! to compute the eigenvalues of the `Poisson2D` matrix A. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvalsh(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Poisson2D` type. It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. !! !! @note !! The eigenvalues of the `Poisson2D` matrix are known analytically !! and can thus be computed efficiently. !! @endnote module function eigvalsh_rdp ( A ) result ( lambda ) type ( Poisson2D ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , target :: lambda (:) !! Eigenvalues. end function end interface interface eigh !! This interface overloads the `eigh` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of the `Poisson2D` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    call eigh(A, lambda, vectors) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Poisson2D` type. It is an `intent(in)` argument. !! !! - `lambda`: Rank-1 `real` array returning the eigenvalues of `A` in !!             increasing order. It is an `intent(out)` argument. !! !! - `vectors`:   Rank-2 `real` array returning the eigenvectors of `A`. !!                It is an `intent(out)` argument. !! !! @note !! Both the eigenvalues and eigenvectors of the `Poisson2D` matrix are !! known analytically and can thus be constructed efficiently. !! @endnote module subroutine eigh_rdp ( A , lambda , vectors ) type ( Poisson2D ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ), target :: lambda (:) !! Eigenvalues. real ( dp ), allocatable , intent ( out ) :: vectors (:, :) end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! Cnvert a matrix of type `Poisson2D` to its dense representation as a !! standard rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Poisson2D` type. It is an `intent(in)` argument. !! !! - `B` :  Rank-2 `real` array corresponding to the dense representation !!          of `A`. pure module function dense_rdp ( A ) result ( B ) type ( Poisson2D ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: B (:, :) !! Dense representation. end function end interface interface shape !! Utility function to return the shape a `Poisson2D` matrix A. pure module function shape_rdp ( A ) result ( arr_shape ) !! Utility function to get the shape of the `Poisson2D` matrix. type ( Poisson2D ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface size !! Utility function to return the size of a `Poisson2D` matrix A !! along a given dimension. pure module function size_rdp ( A , dim ) result ( arr_size ) !! Utility function to return the size of a `Poisson2D` matrix along a given dimension. type ( Poisson2D ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Corresponding size. end function end interface contains end module","tags":"","loc":"sourcefile/specialmatrices_poisson2d.f90.html"},{"title":"det.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_determinant implicit none ( type , external ) contains module procedure det_rdp ! Compute det(A). d = product ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/det.f90~3.html"},{"title":"eig.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_eigenvalue_decomposition use stdlib_linalg , only : stdlib_eig => eig , stdlib_eigvals => eigvals implicit none ( type , external ) contains module procedure eigvals_rdp lambda = stdlib_eigvals ( dense ( A )) end procedure module procedure eig_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) call stdlib_eig ( Amat , lambda , right = right , left = left , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/eig.f90.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_poisson2D ) poisson2D_constructors use stdlib_optval , only : optval implicit none ( type , external ) contains module procedure initialize ! Grid spacing. real ( dp ) :: dx , dy A % nx = nx ; A % ny = ny ; dx = optval ( Lx , 1.0_dp ) / ( nx + 1 ); dy = optval ( Ly , 1.0_dp ) / ( ny + 1 ) A % dx = dx ; A % dy = dy end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~5.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_linear_solver use stdlib_optval , only : optval use stdlib_linalg_lapack , only : pttrf , pttrs , ptrfs use stdlib_linalg_state , only : linalg_state_type , linalg_error_handling , LINALG_ERROR , & LINALG_INTERNAL_ERROR , LINALG_VALUE_ERROR , LINALG_SUCCESS implicit none ( type , external ) character ( * ), parameter :: this = \"strang_linear_solver\" contains module procedure solve_single_rhs ! Local variables. logical ( lk ) :: refine_ real ( dp ), pointer :: xmat (:, :), bmat (:, :) refine_ = optval ( refine , . false .) x = b ; xmat ( 1 : A % n , 1 : 1 ) => x ; bmat ( 1 : A % n , 1 : 1 ) => b xmat = posdef_symtridiagonal_solver ( A , bmat , refine_ ) end procedure module procedure solve_multi_rhs ! Local variables. logical ( lk ) :: refine_ refine_ = optval ( refine , . false .) x = posdef_symtridiagonal_solver ( A , b , refine_ ) end procedure !----------------------------------------------------------- !-----     Positive-definite SymTridiagonal Solver     ----- !----------------------------------------------------------- ! Process PTTRF elemental subroutine handle_pttrf_info ( n , info , err ) integer ( ilp ), intent ( in ) :: n , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid matrix dimension n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"Matrix could not be factorized.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by pttrf\" ) end select end subroutine handle_pttrf_info ! Process PTTRS elemental subroutine handle_pttrs_info ( n , nrhs , ldb , info , err ) integer ( ilp ), intent ( in ) :: n , nrhs , ldb , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for B.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by pttrs\" ) end select end subroutine handle_pttrs_info ! Process PTRFS elemental subroutine handle_ptrfs_info ( n , nrhs , ldb , ldx , info , err ) integer ( ilp ), intent ( in ) :: n , nrhs , ldb , ldx , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for DF.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for EF.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for B.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for X.\" ) case ( - 10 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldx=\" , ldx ) case ( - 11 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ferr.\" ) case ( - 12 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for berr.\" ) case ( - 13 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for work.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by ptrfs\" ) end select end subroutine handle_ptrfs_info function posdef_symtridiagonal_solver ( A , b , refine ) result ( x ) type ( Strang ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), intent ( in ) :: refine !! Iterative refinement of the solution? real ( dp ), allocatable :: x (:, :) !! Solution vectors. ! General LAPACK variables. integer ( ilp ) :: i , n , nrhs , info ! LAPACK variables for LDL&#94;T decomposition. real ( dp ), allocatable :: dv_mat (:), ev_mat (:) real ( dp ), allocatable :: dv (:), ev (:) ! LAPACK variables for iterative refinement. real ( dp ), allocatable :: ferr (:), berr (:), work (:) ! Error handler. type ( linalg_state_type ) :: err ! Initialize data. n = A % n ; nrhs = size ( b , 2 ); x = b !------------------------------------ !-----     LU factorization     ----- !------------------------------------ ! ----- Allocations ----- dv = [( 2 , i = 1 , n )]; ev = [( - 1 , i = 1 , n - 1 )] dv_mat = dv ; ev_mat = ev ! ----- LDL&#94;T factorization ----- call pttrf ( n , dv , ev , info ) call handle_pttrf_info ( n , info , err ) !------------------------------------- !-----     Tridiagonal solve     ----- !------------------------------------- ! ----- Solve the system ----- call pttrs ( n , nrhs , dv , ev , x , n , info ) call handle_pttrs_info ( n , nrhs , n , info , err ) !---------------------------------------- !-----     Iterative refinement     ----- !---------------------------------------- if ( refine ) then ! ----- Allocate arrays ----- allocate ( ferr ( nrhs ), berr ( nrhs ), work ( 2 * n )) ! ----- Refinement step ----- call ptrfs ( n , nrhs , dv_mat , ev_mat , dv , ev , b , n , x , n , ferr , berr , work , info ) call handle_ptrfs_info ( n , nrhs , n , n , info , err ) end if end function posdef_symtridiagonal_solver end submodule","tags":"","loc":"sourcefile/solve.f90~2.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_singular_value_decomposition use stdlib_linalg , only : stdlib_svd => svd , stdlib_svdvals => svdvals implicit none ( type , external ) contains module procedure svdvals_rdp s = stdlib_svdvals ( dense ( A )) end procedure module procedure svd_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) call stdlib_svd ( Amat , s , u , vt , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/svd.f90.html"},{"title":"inv.f90 – SpecialMatrices","text":"Source Code","tags":"","loc":"sourcefile/inv.f90~3.html"},{"title":"SpecialMatrices.f90 – SpecialMatrices","text":"Source Code module SpecialMatrices use specialmatrices_diagonal use specialmatrices_bidiagonal use specialmatrices_tridiagonal use specialmatrices_symtridiagonal use specialmatrices_strang use specialmatrices_poisson2D use specialmatrices_circulant use specialmatrices_toeplitz implicit none private !-------------------------------- !-----     Matrix types     ----- !-------------------------------- public :: Diagonal public :: Bidiagonal public :: Tridiagonal public :: SymTridiagonal public :: Strang public :: Poisson2D public :: Circulant public :: Toeplitz !---------------------------------- !-----     Linear Algebra     ----- !---------------------------------- public :: transpose public :: det public :: trace public :: inv public :: matmul public :: solve public :: svd , svdvals public :: eigh , eigvalsh public :: eig , eigvals !------------------------------------- !-----     Utility functions     ----- !------------------------------------- public :: dense public :: shape public :: size public :: operator ( * ) public :: say_hello contains subroutine say_hello print * , \"Hello, SpecialMatrices!\" end subroutine say_hello end module SpecialMatrices","tags":"","loc":"sourcefile/specialmatrices.f90.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_matvecs use stdlib_linalg_lapack , only : lagtm implicit none ( type , external ) contains module procedure spmv ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp real ( dp ), allocatable :: dummy (:) real ( dp ), pointer :: xmat (:, :), ymat (:, :) ! Setup variables. n = A % n ; nrhs = 1 ; ldx = n ; ldy = n ; trans = \"N\" ; allocate ( dummy ( n - 1 )); dummy = 0.0_dp y = x ; xmat ( 1 : n , 1 : nrhs ) => x ; ymat ( 1 : n , 1 : nrhs ) => y ! Matrix-vector product. select case ( A % which ) case ( \"L\" ) call lagtm ( trans , n , nrhs , alpha , A % ev , A % dv , dummy , xmat , ldx , beta , ymat , ldy ) case ( \"U\" ) call lagtm ( trans , n , nrhs , alpha , dummy , A % dv , A % ev , xmat , ldx , beta , ymat , ldy ) end select end procedure module procedure spmvs ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp real ( dp ), target , allocatable :: dummy (:) ! Setup variables. n = A % n ; nrhs = size ( x , 2 ); ldx = n ; ldy = n ; trans = \"N\" allocate ( dummy ( n - 1 )); dummy = 0.0_dp ; y = x ! Matrix-vector product. select case ( A % which ) case ( \"L\" ) call lagtm ( trans , n , nrhs , alpha , A % ev , A % dv , dummy , x , ldx , beta , y , ldy ) case ( \"U\" ) call lagtm ( trans , n , nrhs , alpha , dummy , A % dv , A % ev , x , ldx , beta , y , ldy ) end select end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~4.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_linear_solver use stdlib_optval , only : optval use stdlib_linalg_lapack , only : gttrf , gttrs , gtrfs use stdlib_linalg_state , only : linalg_state_type , linalg_error_handling , LINALG_ERROR , & LINALG_INTERNAL_ERROR , LINALG_VALUE_ERROR , LINALG_SUCCESS implicit none ( type , external ) character ( * ), parameter :: this = \"tridiagonal_linear_solver\" contains ! Process GTTRF elemental subroutine handle_gttrf_info ( n , info , err ) integer ( ilp ), intent ( in ) :: n , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid problem size n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for dl.\" ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for d.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for du.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for du2.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for ipiv.\" ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"Singular matrix.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gttrf\" ) end select end subroutine handle_gttrf_info ! Process GTTRS elemental subroutine handle_gttrs_info ( trans , n , nrhs , ldb , info , err ) character , intent ( in ) :: trans integer ( ilp ), intent ( in ) :: n , nrhs , ldb , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for trans\" , trans ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid problem size n=\" , n ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid number of rhs nrhs=\" , nrhs ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for dl.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for d.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for du2.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for ipiv.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for b.\" ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gttrs\" ) end select end subroutine handle_gttrs_info ! Process GTRFS elemental subroutine handle_gtrfs_info ( trans , n , nrhs , ldb , ldx , info , err ) character , intent ( in ) :: trans integer ( ilp ), intent ( in ) :: n , nrhs , ldb , ldx , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for trans=\" , trans ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for dl.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for d.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for du.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for dlf.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for df.\" ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for duf.\" ) case ( - 10 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for du2.\" ) case ( - 11 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ipiv.\" ) case ( - 12 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for b.\" ) case ( - 13 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case ( - 14 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for x.\" ) case ( - 15 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldx=\" , ldx ) case ( - 16 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ferr.\" ) case ( - 17 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for berr.\" ) case ( - 18 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for work.\" ) case ( - 19 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for iwork.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gtrfs\" ) end select end subroutine handle_gtrfs_info function tridiagonal_solver ( A , b , refine ) result ( x ) type ( Tridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), intent ( in ) :: refine !! Iterative refinement of the solution? real ( dp ), allocatable :: x (:, :) !! Solution vectors. ! General LAPACK variables. integer ( ilp ) :: n , nrhs , info ! LAPACK variables for LU decomposition. real ( dp ), allocatable :: dl (:), d (:), du (:), du2 (:) integer ( ilp ), allocatable :: ipiv (:) ! LAPACK variables for iterative refinement. real ( dp ), allocatable :: ferr (:), berr (:), work (:) integer ( ilp ), allocatable :: iwork (:) ! Error handler. type ( linalg_state_type ) :: err ! Initialize data. n = A % n ; nrhs = size ( b , 2 ); x = b !------------------------------------ !-----     LU factorization     ----- !------------------------------------ ! ----- Allocations ----- allocate ( du2 ( n - 2 ), ipiv ( n )) dl = A % dl ; d = A % dv ; du = A % du ; ! ----- LU factorization ----- call gttrf ( n , dl , d , du , du2 , ipiv , info ) call handle_gttrf_info ( n , info , err ) !------------------------------------- !-----     Tridiagonal solve     ----- !------------------------------------- ! ----- Solve the system ----- call gttrs ( \"N\" , n , nrhs , dl , d , du , du2 , ipiv , x , n , info ) call handle_gttrs_info ( \"N\" , n , nrhs , n , info , err ) !---------------------------------------- !-----     Iterative refinement     ----- !---------------------------------------- if ( refine ) then ! ----- Allocate arrays ----- allocate ( ferr ( nrhs ), berr ( nrhs ), work ( 3 * n ), iwork ( n )) ! ----- Refinement step ----- call gtrfs ( \"N\" , n , nrhs , A % dl , A % dv , A % du , dl , d , du , du2 , ipiv , b , & n , x , n , ferr , berr , work , iwork , info ) call handle_gtrfs_info ( \"N\" , n , nrhs , n , n , info , err ) end if end function tridiagonal_solver module procedure solve_single_rhs ! Local variables. logical ( lk ) :: refine_ real ( dp ), pointer :: xmat (:, :), bmat (:, :) refine_ = optval ( refine , . false .) x = b ; xmat ( 1 : A % n , 1 : 1 ) => x ; bmat ( 1 : A % n , 1 : 1 ) => b xmat = tridiagonal_solver ( A , bmat , refine_ ) end procedure module procedure solve_multi_rhs ! Local variables. logical ( lk ) :: refine_ refine_ = optval ( refine , . false .) x = tridiagonal_solver ( A , b , refine_ ) end procedure end submodule","tags":"","loc":"sourcefile/solve.f90~3.html"},{"title":"specialmatrices_strang.f90 – SpecialMatrices","text":"Source Code module specialmatrices_strang use stdlib_linalg_constants , only : dp , ilp , lk implicit none ( type , external ) private ! --> Linear algebra public :: det , trace public :: matmul public :: solve public :: eigh , eigvalsh ! --> Utility functions. public :: dense public :: shape public :: size !--------------------------------------------------- !-----     Base type for the Strang matrix     ----- !--------------------------------------------------- type , public :: Strang !! Base type used to define the `Strang` matrix. integer ( ilp ) :: n !! Dimension of the matrix. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Strang !! Constructor for generating the `Strang` matrix of size `n`. The !! matrix corresponds to the standard 3-point finite-difference !! approximation of the 1D Laplace operator with unit grid-spacing !! (\\Delta x = 1) and homogeneous Dirichlet boundary conditions. !! It reads !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       2  &  -1 \\\\ !!       -1 &  2        &  -1 \\\\ !!          &  \\ddots   &  \\ddots   &  \\ddots   \\\\ !!          &           &  -1       &  2  &  -1 \\\\ !!          &           &           &  -1 &  2 !!    \\end{bmatrix} !!  !! !! #### Syntax !! !! - Construct a `Strang` matrix of size 100. !! !! ```fortran !!    integer, parameter :: n = 100 !!    type(Strang) :: S !!    S = Strang(n) !! ``` !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function initialize ( n ) result ( A ) !! Construct the Strang matrix of size `n`. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Strang ) :: A !! Strang matrix of size `n`. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for the !! `Strang` matrix, both for matrix-vector and matrix-matrix products. !! For matrix-matrix product  C = A B , only A can be a `Strang` !! matrix. Both  B  and  C  are standard rank-2 arrays. All !! underlying functions are defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` pure module function spmv ( A , x ) result ( y ) !! Driver for the matrix-vector product. type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:) !! Input vector. real ( dp ), allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , X ) result ( Y ) !! Driver for the matrix-matrix product. type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: X (:, :) !! Input vector. real ( dp ), allocatable :: Y (:, :) !! Output vector. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a system Ax = b where A is a `Strang` matrix. !! It also enables to solve a linear system with multiple right-hand !! sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Strang` type. It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. It has the same type and !!          shape as `b`. module function solve_single_rhs ( A , b , refine ) result ( x ) type ( Strang ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), target , intent ( in ) :: b (:) !! Right-hand side vector. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refinement is used or not. real ( dp ), allocatable , target :: x (:) !! Solution vector. end function module function solve_multi_rhs ( A , b , refine ) result ( x ) type ( Strang ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refinement is used or not. real ( dp ), allocatable :: x (:, :) !! Solution vectors. end function end interface !----------------------------------------- !-----     Determinant and Trace     ----- !----------------------------------------- interface det !! This interface overloads the `det` interface from `stdlib_linalg` !! to compute the determinant \\det(A) where A is of type !! `Strang`. !! !! #### Syntax !! !! ```fortran !!    d = det(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of type `Strang`. It is an `intent(in)` argument. !! !! - `d` :  Determinant of the matrix. pure module function det_rdp ( A ) result ( d ) type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ) :: d !! Determinant of the matrix. end function end interface interface trace !! This interface overloads the `trace` interface from `stdlib_linalg` !! to compute the trace of a matrix A of type `Strang`. !! !! #### Strang !! !! ```fortran !!    tr = trace(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Strang` type. It is an `intent(in)` argument. !! !! - `tr`:  Trace of the matrix. pure module function trace_rdp ( A ) result ( tr ) type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ) :: tr !! Trace of the matrix. end function end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvalsh !! This interface overloads the `eigvalsh` interface from `stdlib_linalg` !! to compute the eigenvalues of a `Strang` matrix. Note that these !! eigenvalues are known analytically. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvalsh(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of type `Strang`. It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. pure module function eigvalsh_rdp ( A ) result ( lambda ) type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eigh !! This interface overloads the `eigh` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of a `Strang` matrix. !! !! #### Syntax !! !! ```fortran !!    call eigh(A, lambda, vectors) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of type `Strang`. It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! -  `vectors`:  Rank-2 `real` array of size `[n x n]` returning the !!                eigenvectors of `A`. It is an `intent(out)` argument. !! !! @note !! Eigenvalues and eigenvectors of the Strang matrix are known !! analytically and can thus be constructed very efficiently. !! @endnote pure module subroutine eigh_rdp ( A , lambda , vectors ) type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ) :: lambda (:) !! Eigenvalues. real ( dp ), allocatable , intent ( out ) :: vectors (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! Convert a matrix of type `Strang` to its dense representation as a !! standard rank-2 array !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of type `Strang`. It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation fo the matrix A. pure module function dense_rdp ( A ) result ( B ) type ( Strang ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: B (:, :) !! Dense representation. end function end interface interface shape !! Utility function returning the shape of a `Strang` matrix A. pure module function shape_rdp ( A ) result ( arr_shape ) type ( Strang ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface size !! Utility function returning the size of a `Strang` matrix A !! along a given dimension. pure module function size_rdp ( A , dim ) result ( arr_size ) type ( Strang ), intent ( in ) :: A !! Input matrix. integer ( ilp ), intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Corresponding size. end function end interface contains end module","tags":"","loc":"sourcefile/specialmatrices_strang.f90.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_matvecs implicit none ( type , external ) contains module procedure spmv integer ( ilp ) :: i y = x y = real ( ifft ( fft ( cmplx ( y , kind = dp ), A % n ) * A % c_hat , A % n )) / A % n end procedure module procedure spmvs integer ( ilp ) :: i y = x do concurrent ( i = 1 : size ( x , 2 )) y (:, i ) = matmul ( A , x (:, i )) enddo end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~5.html"},{"title":"eigh.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_poisson2D ) poisson2D_eigh use stdlib_constants , only : pi => pi_dp use stdlib_sorting , only : sort , sort_index use stdlib_linalg , only : outer_product implicit none ( type , external ) contains module procedure eigvalsh_rdp integer ( ilp ) :: i , j real ( dp ), pointer :: lambda_mat (:, :) !> Eigenvalues for Dx and Dy. real ( dp ), allocatable :: lambda_x (:), lambda_y (:) lambda_x = - eigvalsh ( Strang ( A % nx )) / A % dx ** 2 lambda_y = - eigvalsh ( Strang ( A % ny )) / A % dy ** 2 !> Eigenvalues of the 2D Poisson operator. allocate ( lambda ( A % nx * A % ny )) ; lambda_mat ( 1 : A % nx , 1 : A % ny ) => lambda do concurrent ( i = 1 : A % nx , j = 1 : A % ny ) lambda_mat ( i , j ) = lambda_x ( i ) + lambda_y ( j ) enddo !> Sort eigenvalues. call sort ( lambda ) end procedure module procedure eigh_rdp integer ( ilp ) :: i , j , index ( A % nx * A % ny ) integer ( ilp ) :: nx , ny , n , counter real ( dp ), pointer :: lambda_mat (:, :) real ( dp ), allocatable :: lambda_x (:), lambda_y (:) real ( dp ), allocatable :: vecs_x (:, :), vecs_y (:, :) nx = A % nx ; ny = A % ny ; n = nx * ny !> Eigenvalues and eigevectors for Dx and Dy. call eigh ( Strang ( A % nx ), lambda_x , vecs_x ) call eigh ( Strang ( A % ny ), lambda_y , vecs_y ) !> Scale eigenvalues. lambda_x = - lambda_x / A % dx ** 2 lambda_y = - lambda_y / A % dy ** 2 !> Eigenvalues of the 2D Poisson operator. allocate ( lambda ( n )) ; lambda_mat ( 1 : nx , 1 : ny ) => lambda do concurrent ( i = 1 : nx , j = 1 : ny ) lambda_mat ( i , j ) = lambda_x ( i ) + lambda_y ( j ) enddo !> Eigenvectors of the 2D Poisson operator. allocate ( vectors ( n , n )) ; vectors = 0.0_dp ; counter = 1 do j = 1 , ny do i = 1 , nx vectors (:, counter ) = pack ( outer_product ( vecs_x (:, i ), vecs_y (:, j )), . true .) counter = counter + 1 enddo enddo !> Sort eigenvalues and eigenvectors. call sort_index ( lambda , index ) ; vectors = vectors (:, index ) end procedure end submodule","tags":"","loc":"sourcefile/eigh.f90~2.html"},{"title":"inv.f90 – SpecialMatrices","text":"Source Code","tags":"","loc":"sourcefile/inv.f90~4.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_matvecs use stdlib_linalg_lapack , only : lagtm implicit none ( type , external ) contains module procedure spmv ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp real ( dp ), pointer :: xmat (:, :), ymat (:, :) ! Setup variables. n = A % n ; nrhs = 1 ; ldx = n ; ldy = n ; trans = \"N\" y = x ; xmat ( 1 : n , 1 : nrhs ) => x ; ymat ( 1 : n , 1 : nrhs ) => y ! Matrix-vector product. call lagtm ( trans , n , nrhs , alpha , A % ev , A % dv , A % ev , xmat , ldx , beta , ymat , ldy ) end procedure module procedure spmvs ! Local variables. character :: trans integer ( ilp ) :: n , nrhs , ldx , ldy real ( dp ), parameter :: alpha = 1.0_dp , beta = 0.0_dp ! Setup variables. n = A % n ; nrhs = size ( x , 2 ); ldx = n ; ldy = n ; trans = \"N\" ; y = x ! Matrix-vector product. call lagtm ( trans , n , nrhs , alpha , A % ev , A % dv , A % ev , x , ldx , beta , y , ldy ) end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~6.html"},{"title":"inv.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_inverse implicit none ( type , external ) contains module procedure inv_rdp B = circulant ( real ( ifft ( 1.0_dp / A % c_hat )) / A % n ) end procedure end submodule","tags":"","loc":"sourcefile/inv.f90~5.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_linear_solver implicit none ( type , external ) contains module procedure solve_single_rhs ! Solve Ax = b. integer ( ilp ) :: i allocate ( x , mold = b ) do concurrent ( i = 1 : A % n ) x ( i ) = b ( i ) / A % dv ( i ) end do end procedure module procedure solve_multi_rhs ! Solve AX = B. integer ( ilp ) :: i , j real ( dp ), allocatable :: inv_dv (:) allocate ( x , mold = b ); inv_dv = 1.0_dp / A % dv do concurrent ( i = 1 : A % n , j = 1 : size ( b , 2 )) x ( i , j ) = b ( i , j ) * inv_dv ( i ) end do end procedure end submodule","tags":"","loc":"sourcefile/solve.f90~4.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_utils implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: i , n n = A % n ; allocate ( B ( n , n )); B = 0.0_dp select case ( A % which ) case ( \"L\" ) B ( 1 , 1 ) = A % dv ( 1 ) do concurrent ( i = 2 : n ) B ( i , i ) = A % dv ( i ) B ( i , i - 1 ) = A % ev ( i - 1 ) end do case ( \"U\" ) do concurrent ( i = 1 : n - 1 ) B ( i , i ) = A % dv ( i ) B ( i , i + 1 ) = A % ev ( i ) end do B ( n , n ) = A % dv ( n ) end select end procedure module procedure transpose_rdp B = A if ( A % which == \"L\" ) then B % which = \"U\" else B % which = \"L\" end if end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure size_rdp arr_size = A % n end procedure module procedure scalar_multiplication_rdp B = Bidiagonal ( alpha * A % dv , alpha * A % ev , A % which ) end procedure module procedure scalar_multiplication_bis_rdp B = Bidiagonal ( alpha * A % dv , alpha * A % ev , A % which ) end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~5.html"},{"title":"det.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_determinant implicit none ( type , external ) contains module procedure det_rdp d = product ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/det.f90~4.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_singular_value_decomposition use stdlib_sorting , only : sort , sort_index use stdlib_linalg , only : eye implicit none ( type , external ) contains module procedure svdvals_rdp s = abs ( A % dv ); call sort ( s , reverse = . true .) end procedure module procedure svd_rdp integer ( ilp ) :: i , index ( A % n ) ! Sorted singular values. s = abs ( A % dv ); call sort_index ( s , index , reverse = . true .) ! Left singular vectors. u = eye ( A % n ); u = u (:, index ) ! Right singular vectors. vt = eye ( A % n ) do concurrent ( i = 1 : A % n , A % dv ( i ) < 0.0_dp ) vt ( i , i ) = - 1.0_dp end do vt = vt ( index , :) end procedure end submodule","tags":"","loc":"sourcefile/svd.f90~2.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_utilities implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: j , n n = A % n ; allocate ( B ( n , n )) ; B = 0.0_dp do concurrent ( j = 1 : n ) B (:, j ) = cshift ( A % c , - j + 1 ) enddo end procedure module procedure transpose_rdp real ( dp ), allocatable :: b_vec (:) integer ( ilp ) :: n n = A % n b_vec = A % c ( n : 1 : - 1 ) ; b_vec = cshift ( b_vec , - 1 ) B = Circulant ( b_vec ) end procedure module procedure size_rdp arr_size = A % n end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure scalar_multiplication_rdp B = Circulant ( alpha * A % c ) end procedure module procedure scalar_multiplication_bis_rdp B = Circulant ( alpha * A % c ) end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~6.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_utils implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: i , n n = A % n ; allocate ( B ( n , n )); B = 0.0_dp B ( 1 , 1 ) = A % dv ( 1 ); B ( 1 , 2 ) = A % ev ( 1 ) do concurrent ( i = 2 : n - 1 ) B ( i , i - 1 ) = A % ev ( i - 1 ) B ( i , i ) = A % dv ( i ) B ( i , i + 1 ) = A % ev ( i ) end do B ( n , n - 1 ) = A % ev ( n - 1 ); B ( n , n ) = A % dv ( n ) end procedure module procedure transpose_rdp B = A end procedure module procedure shape_rdp arr_shape = A % n end procedure module procedure size_rdp arr_size = A % n end procedure module procedure scalar_multiplication_rdp B = SymTridiagonal ( alpha * A % dv , alpha * A % ev ) if ( alpha <= 0.0_dp ) B % isposdef = . false . end procedure module procedure scalar_multiplication_bis_rdp B = SymTridiagonal ( alpha * A % dv , alpha * A % ev ) if ( alpha <= 0.0_dp ) B % isposdef = . false . end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~7.html"},{"title":"utils.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_utilities implicit none ( type , external ) contains module procedure dense_rdp integer ( ilp ) :: i , j , m , n real ( dp ), allocatable :: t (:) m = A % m ; n = A % n ; allocate ( t ( - ( n - 1 ): m - 1 )) ; allocate ( B ( m , n )) t (: - 1 ) = A % vr ( n : 2 : - 1 ) t ( 0 :) = A % vc do concurrent ( i = 1 : m , j = 1 : n ) B ( i , j ) = t ( i - j ) enddo end procedure module procedure transpose_rdp B = Toeplitz ( A % vr , A % vc ) end procedure module procedure size_rdp if ( present ( dim )) then select case ( dim ) case ( 1 ) arr_size = A % m case ( 2 ) arr_size = A % n case default error stop \"Matrix has only two dimensions.\" end select else arr_size = A % m * A % n endif end procedure module procedure shape_rdp arr_shape = [ A % m , A % n ] end procedure module procedure scalar_multiplication_rdp B = Toeplitz ( alpha * A % vc , alpha * A % vr ) end procedure module procedure scalar_multiplication_bis_rdp B = Toeplitz ( alpha * A % vc , alpha * A % vr ) end procedure module procedure Toeplitz2Circulant real ( dp ), allocatable :: c_vec (:) integer ( ilp ) :: m , n m = T % m ; n = T % n ; allocate ( c_vec ( m + n )) c_vec (: m ) = T % vc ; c_vec ( m + 1 :) = cshift ( T % vr ( n : 1 : - 1 ), - 1 ) C = Circulant ( c_vec ) end procedure end submodule","tags":"","loc":"sourcefile/utils.f90~8.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_constructors implicit none ( type , external ) contains module procedure initialize A % n = n end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~6.html"},{"title":"specialmatrices_diagonal.f90 – SpecialMatrices","text":"Source Code module specialmatrices_diagonal use stdlib_linalg_constants , only : dp , ilp implicit none private ! --> Linear Algebra. public :: transpose public :: det , trace public :: matmul public :: inv public :: solve public :: svd , svdvals public :: eigh , eigvalsh ! --> Utility functions. public :: dense public :: shape public :: size public :: operator ( * ) !---------------------------------------------------- !-----     Base types for Diagonal matrices     ----- !---------------------------------------------------- type , public :: Diagonal !! Base type used to define a `Diagonal` matrix of size `[n x n]` !! with diagonal elements given by the rank-1 array `dv`. private integer ( ilp ) :: n !! Dimension of the matrix. real ( dp ), allocatable :: dv (:) !! Diagonal elements of the matrix. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Diagonal !! This interface provides different methods to construct a `Diagonal` !! matrix. Only the diagonal elements of  A  are being stored, i.e. !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       d_1 \\\\ !!          &  d_2 \\\\ !!          &     &  \\ddots   \\\\ !!          &     &        &  d_n !!    \\end{bmatrix}. !!  !! !! #### Syntax !! !! - Construct a `Diagonal` matrix filled with zeros: !! !! ```fortran !!    integer, parameter :: n = 100 !!    type(Diagonal) :: A !! !!    A = Diagonal(n) !! ``` !! !! - Construct a `Diagonal` matrix from a vector. !! !! ```fortran !!    integer, parameter :: n = 100 !!    real(dp), allocatable :: dv(:) !!    type(Diagonal) :: A !!    integer :: i !! !!    dv = [(i, i=1, n)]; A = Diagonal(dv) !! ``` !! !! - Construct a `Diagonal` matrix with constant diagonal element. !! !! ```fortran !!    integer, parameter :: n = 100 !!    real(dp), parameter :: d = 2.0_dp !!    type(Diagonal) :: A !! !!    A = Diagonal(d, n) !! ``` !! !! - Construct a `Diagonal` matrix from a standard rank-2 array. !! !! ```fortran !!    integer, parameter :: n = 100 !!    real(dp) :: B(n, n) !!    type(Diagonal) :: A !! !!    call random_number(B); A = Diagonal(B) !! ``` !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function initialize ( n ) result ( A ) !! Utility function to construct a `Diagonal` matrix filled with !! zeros. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Diagonal ) :: A !! Corresponding diagonal matrix. end function initialize pure module function construct ( dv ) result ( A ) !! Utility function to construct a `Diagonal` matrix from a rank-1 !! array. real ( dp ), intent ( in ) :: dv (:) !! Diagonal elements of the matrix. type ( Diagonal ) :: A !! Corresponding diagonal matrix. end function construct pure module function construct_constant ( d , n ) result ( A ) !! Utility function to construct a `Diagonal` matrix with constant !! diagonal element. real ( dp ), intent ( in ) :: d !! Constant diagonal element of the matrix. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Diagonal ) :: A !! Corresponding diagonal matrix. end function construct_constant module function dense_to_diag ( A ) result ( B ) !! Utility function to construct a `Diagonal` matrix from a rank-2 !! array. The resulting matrix is constructed from the diagonal !! element of the input matrix, even if the latter is not diagonal. real ( dp ), intent ( in ) :: A (:, :) !! Dense n \\times n matrix from which to construct the !! `Diagonal` one. type ( Diagonal ) :: B !! Corresponding diagonal matrix. end function dense_to_diag end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Diagonal` matrix, both for matrix-vector and matrix-matrix !! products. For a matrix-matrix product  C = AB , only the matrix !!  A  has to be a `Diagonal` matrix. Both  B  and  C  !! need to be standard Fortran rank-2 arrays. All the underlying !! functions are defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` pure module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product y = Ax for a `Diagonal` !! matrix A. Both `x` and `y` are rank-1 arrays with the same !! kind as `A`. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: x (:) !! Input vector. real ( dp ), allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , X ) result ( Y ) !! Compute the matrix-matrix product Y = AX for a `Diagonal` !! matrix A and a dense matrix X (rank-2 array). Y is !! also a rank-2 array with the same dimensions as X. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: X (:, :) !! Input vectors. real ( dp ), allocatable :: Y (:, :) !! Output vectors. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a !! `Diagonal` matrix. It also enables to solve a linear system with !! multiple right-hand sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. It has the same type and !!          shape as `b`. pure module function solve_single_rhs ( A , b ) result ( x ) !! Solve the linear system Ax=b where A is of type !! `Diagonal` and `b` a standard rank-1 array. The solution vector !! `x` has the same dimension and kind as the right-hand side !! vector `b`. type ( Diagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable :: x (:) !! Solution vector. end function pure module function solve_multi_rhs ( A , b ) result ( x ) !! Solve the linear system AX=B where A is of type !! `Diagonal` and `B` a standard rank-2 array. The solution matrix !! `X` has the same dimensions and kind as the right-hand side !! matrix `B`. type ( Diagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: B (:, :) !! Right-hand side vectors. real ( dp ), allocatable :: X (:, :) !! Solution vectors. end function end interface interface inv pure module function inv_rdp ( A ) result ( B ) !! Utility function to compute the inverse of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. type ( Diagonal ) :: B !! Inverse of `A`. end function end interface !----------------------------------------- !-----     Determinant and Trace     ----- !----------------------------------------- interface det !! This interface overloads the `det` interface from `stdlib_linag` to !! compute the determinant \\det(A) where A is of type !! `Diagonal`. !! !! #### Syntax !! !! ```fortran !!    d = det(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is in an `intent(in)` argument. !! !! - `d` :  Determinant of the matrix. pure module function det_rdp ( A ) result ( d ) !! Compute the determinant of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: d !! Determinant of the matrix. end function end interface interface trace !! This interface overloads the `trace` interface from `stdlib_linalg` !! to compute the trace of a matrix  A  of type `Diagonal`. !! !! #### Syntax !! !! ```fortran !!    tr = trace(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is an `intent(in)` argument. !! !! - `tr`:  Trace of the matrix. pure module function trace_rdp ( A ) result ( tr ) !! Compute the trace of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: tr !! Trace of the matrix. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from !! `stdlib_linalg` to compute the singular values of a `Diagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. pure module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` !! to compute the the singular value decomposition of a `Diagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s [, u] [, vt]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 `real` array returning the singular values !!          of `A`. It is an `intent(out)` argument. !! !! - `u` (optional)  :  Rank-2 array of the same kind as `A` returning !!                   the left singular vectors of `A` as columns. Its !!                   size should be `[n, n]`. It is an `intent(out)` !!                   argument. !! !! - `vt` (optional) :  Rank-2 array of the same kind as `A` returning !!                   the right singular vectors of `A` as rows. Its !!                   size should be `[n, n]`. It is an `intent(out)` !!                   argument. module subroutine svd_rdp ( A , u , s , vt ) !! Compute the singular value decomposition of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), allocatable , optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), allocatable , optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvalsh !! This interface overloads the `eigvalsh` interface from !! `stdlib_linalg` to compute the eigenvalues of a real-valued matrix !!  A  whose type is `Diagonal`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvalsh(A) !! ``` !! !! #### Arguments !! !! - `A`       :  `real`-valued matrix of `Diagonal` type. !!                It is an `intent(in)` argument. !! !! - `lambda`  :   Vector of eigenvalues in increasing order. module function eigvalsh_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real `Diagonal` !! matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eigh !! This interface overloads the `eigh` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of a real-valued matrix !! A whose type is `Diagonal`. !! !! #### Syntax !! !! ```fortran !!    call eigh(A, lambda [, vectors]) !! ``` !! !! #### Arguments !! !! - `A`       : `real`-valued matrix of `Diagonal`. !!                It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! - `vectors` (optional)  :  Rank-2 array of the same kind as `A` !!                            returning the eigenvectors of `A`. It is !!                            an `intent(out)` argument. module subroutine eigh_rdp ( A , lambda , vectors ) !! Utility function to compute the eigenvalues and eigenvectors of !! a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable , intent ( out ) :: lambda (:) !! Eigenvalues. real ( dp ), allocatable , optional , intent ( out ) :: vectors (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! This interface provides methods to convert a `Diagonal` matrix to a !! regular rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . module function dense_rdp ( A ) result ( B ) !! Convert a `Diagonal` matrix to a rank-2 array. type ( Diagonal ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose operation for a `Diagonal` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Diagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Utility function to compute the transpose of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. type ( Diagonal ) :: B !! Transpose of the matrix. end function end interface interface size pure module function size_rdp ( A , dim ) result ( arr_size ) !! Utility function to return the size of `Diagonal` matrix along a !! given dimension. type ( Diagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape pure module function shape_rdp ( A ) result ( arr_shape ) !! Utility function to get the shape of a `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Diagonal` matrix. real ( dp ), intent ( in ) :: alpha type ( Diagonal ), intent ( in ) :: A type ( Diagonal ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Utility function to perform a scalar multiplication with a !! `Diagonal` matrix. type ( Diagonal ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( Diagonal ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_diagonal.f90.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_constructors implicit none ( type , external ) contains module procedure initialize A % n = n ; allocate ( A % dl ( n - 1 )); allocate ( A % dv ( n )); allocate ( A % du ( n - 1 )) A % dl = 0.0_dp ; A % dv = 0.0_dp ; A % du = 0.0_dp end procedure module procedure construct integer ( ilp ) :: n n = size ( dv ) A % n = n ; A % dl = dl ; A % dv = dv ; A % du = du end procedure module procedure construct_constant integer ( ilp ) :: i A % n = n A % dl = [( dl , i = 1 , n - 1 )]; A % dv = [( dv , i = 1 , n )]; A % du = [( du , i = 1 , n - 1 )] end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~7.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_matvecs contains module procedure spmv integer ( ilp ) :: m , n real ( dp ), allocatable :: x_circ (:), y_circ (:) !> Dimension of the matrix. m = A % m ; n = A % n !> Allocate variables. allocate ( x_circ ( m + n )) ; x_circ = 0.0_dp ; x_circ (: n ) = x !> Toeplitz spmv via Circulant embedding. y_circ = matmul ( Circulant ( A ), x_circ ) ; y = y_circ (: m ) end procedure module procedure spmvs integer ( ilp ) :: m , n real ( dp ), allocatable :: x_circ (:, :), y_circ (:, :) !> Dimension of the matrix. m = A % m ; n = A % n !> Allocate variables. allocate ( x_circ ( m + n , size ( x , 2 ))) ; x_circ = 0.0_dp ; x_circ (: n , :) = x !> Toeplitz spmv via Circulant embedding. y_circ = matmul ( Circulant ( A ), x_circ ) ; y = y_circ (: m , :) end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~7.html"},{"title":"eigh.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strang_eigh use stdlib_constants , only : pi => pi_dp implicit none ( type , external ) contains module procedure eigvalsh_rdp integer ( ilp ) :: k , n n = A % n ; lambda = 2 * [( 1 - cos (( pi * k ) / ( n + 1 )), k = 1 , n )] end procedure module procedure eigh_rdp integer ( ilp ) :: i , j , n n = A % n lambda = eigvalsh ( A ) allocate ( vectors ( n , n )) do concurrent ( i = 1 : n , j = 1 : n ) vectors ( i , j ) = sqrt ( 2.0_dp / ( n + 1 )) * sin (( i * j * pi ) / ( n + 1 )) end do end procedure end submodule","tags":"","loc":"sourcefile/eigh.f90~3.html"},{"title":"det.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_determinant implicit none ( type , external ) contains module procedure det_rdp real ( dp ) :: f_0 , f_1 integer ( ilp ) :: i f_0 = 1.0_dp ; f_1 = 0.0_dp ! First iteration. d = A % dv ( 1 ) * f_0 ; f_1 = f_0 ; f_0 = d ! Continuants do i = 2 , A % n ! Reccurence relation. d = A % dv ( i ) * f_0 - A % ev ( i - 1 ) ** 2 * f_1 ! Store previous values. f_1 = f_0 ; f_0 = d end do end procedure end submodule","tags":"","loc":"sourcefile/det.f90~5.html"},{"title":"eig.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_eigenvalue_decomposition use stdlib_linalg , only : stdlib_eig => eig , stdlib_eigvals => eigvals implicit none ( type , external ) contains module procedure eigvals_rdp lambda = stdlib_eigvals ( dense ( A )) end procedure module procedure eig_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) call stdlib_eig ( Amat , lambda , right = right , left = left , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/eig.f90~2.html"},{"title":"trace.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_strang ) strange_trace implicit none ( type , external ) contains module procedure trace_rdp tr = A % n * 2 end procedure end submodule","tags":"","loc":"sourcefile/trace.f90~3.html"},{"title":"trace.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_tridiagonal ) tridiagonal_trace implicit none ( type , external ) contains module procedure trace_rdp tr = sum ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/trace.f90~4.html"},{"title":"constructors.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_constructors use stdlib_linalg , only : diag implicit none ( type , external ) contains module procedure initialize ! Utility function to construct a `Diagonal` matrix filled with zeros. A % n = n ; allocate ( A % dv ( n )); A % dv = 0.0_dp end procedure module procedure construct ! Utility function to construct a `Diagonal` matrix from a rank-1 array. A % n = size ( dv ); A % dv = dv end procedure module procedure construct_constant ! Utility function to construct a `Diagonal` matrix with constant value. integer ( ilp ) :: i A % n = n ; A % dv = [( d , i = 1 , n )] end procedure module procedure dense_to_diag ! Utility function to construct a `Diagonal` matrix from a rank-2 array. B = Diagonal ( diag ( A )) end procedure end submodule","tags":"","loc":"sourcefile/constructors.f90~8.html"},{"title":"eigh.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_hermitian_eigenvalue_decomposition use stdlib_sorting , only : sort , sort_index use stdlib_linalg , only : eye implicit none ( type , external ) contains module procedure eigvalsh_rdp lambda = A % dv ; call sort ( lambda ) end procedure module procedure eigh_rdp integer ( ilp ) :: index ( A % n ) ! Eigenvalues. lambda = A % dv ; call sort_index ( lambda , index ) ! Eigenvectors. if ( present ( vectors )) then vectors = eye ( A % n ); vectors = vectors (:, index ) end if end procedure end submodule","tags":"","loc":"sourcefile/eigh.f90~4.html"},{"title":"eig.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_eigenvalue_decomposition use stdlib_linalg , only : hermitian , eye implicit none ( type , external ) contains module procedure eigvals_rdp lambda = A % c_hat end procedure module procedure eig_rdp real ( dp ), allocatable :: Amat (:, :) integer ( ilp ) :: i , n n = A % n lambda = A % c_hat if ( present ( right )) then right = eye ( n , mold = 1.0_dp ) do concurrent ( i = 1 : n ) right (:, i ) = fft ( right (:, i ), n ) / sqrt ( 1.0_dp * n ) enddo right = hermitian ( right ) endif if ( present ( left )) then left = eye ( n , mold = 1.0_dp ) do concurrent ( i = 1 : n ) left (:, i ) = ifft ( left (:, i ), n ) / sqrt ( 1.0_dp * n ) enddo endif end procedure end submodule","tags":"","loc":"sourcefile/eig.f90~3.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_singular_value_decomposition use stdlib_linalg , only : stdlib_svd => svd , stdlib_svdvals => svdvals implicit none ( type , external ) contains module procedure svdvals_rdp s = stdlib_svdvals ( dense ( A )) end procedure module procedure svd_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) call stdlib_svd ( Amat , s , u , vt , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/svd.f90~3.html"},{"title":"eig.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_eigendecomposition implicit none ( type , external ) contains module procedure eigvals_rdp lambda = eigvals ( dense ( A )) end procedure module procedure eig_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) ; call eig ( Amat , lambda , right = right , left = left , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/eig.f90~4.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_bidiagonal ) bidiagonal_linear_solver use stdlib_linalg_lapack , only : gtsv use stdlib_linalg_state , only : linalg_state_type , linalg_error_handling , LINALG_ERROR , & LINALG_INTERNAL_ERROR , LINALG_VALUE_ERROR , LINALG_SUCCESS implicit none ( type , external ) character ( * ), parameter :: this = \"bidiagonal_linear_solver\" contains elemental subroutine handle_gtsv_info ( n , nrhs , ldb , info , err ) integer ( ilp ), intent ( in ) :: n , nrhs , ldb , info type ( linalg_state_type ), intent ( out ) :: err select case ( info ) case ( 0 ) err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for DL.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for DU.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for b.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"System is singular.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gtsv.\" ) end select return end subroutine handle_gtsv_info module procedure solve_single_rhs type ( linalg_state_type ) :: err0 integer ( ilp ) :: i , n , nrhs , info real ( dp ), allocatable :: dl (:), dv (:), du (:) real ( dp ), pointer :: xmat (:, :) ! Initialize arrays. n = A % n ; nrhs = 1 x = b ; xmat ( 1 : n , 1 : nrhs ) => x ! Dispatch to solver. select case ( A % which ) case ( \"L\" ) dv = A % dv ; dl = A % ev ; du = 0.0_dp * A % ev case ( \"U\" ) dv = A % dv ; dl = 0.0_dp * A % ev ; du = A % ev end select ! Solve. call gtsv ( n , nrhs , dl , dv , du , xmat , n , info ) call handle_gtsv_info ( n , nrhs , n , info , err0 ) end procedure module procedure solve_multi_rhs type ( linalg_state_type ) :: err0 integer ( ilp ) :: i , n , nrhs , info real ( dp ), allocatable :: dl (:), dv (:), du (:) ! Initialize arrays. n = A % n ; nrhs = size ( b , 2 ); x = b ! Dispatch to solver. select case ( A % which ) case ( \"L\" ) dv = A % dv ; dl = A % ev ; du = 0.0_dp * A % ev case ( \"U\" ) dv = A % dv ; dl = 0.0_dp * A % ev ; du = A % ev end select ! Solve. call gtsv ( n , nrhs , dl , dv , du , x , n , info ) call handle_gtsv_info ( n , nrhs , n , info , err0 ) end procedure end submodule","tags":"","loc":"sourcefile/solve.f90~5.html"},{"title":"trace.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_diagonal ) diagonal_trace implicit none ( type , external ) contains module procedure trace_rdp tr = sum ( A % dv ) end procedure end submodule","tags":"","loc":"sourcefile/trace.f90~5.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_singular_value_decomposition implicit none ( type , external ) contains module procedure svdvals_rdp ! Get singular values from the eigendecomposition. s = abs ( eigvalsh ( A )) end procedure module procedure svd_rdp integer ( ilp ) :: i , n n = A % n ! Compute eigendecomposition. call eigh ( A , s , u ) ! Left singular vectors. if ( present ( vt )) then vt = u do concurrent ( i = 1 : n , s ( i ) < 0.0_dp ) vt (:, i ) = - 1.0_dp * vt (:, i ) end do vt = transpose ( vt ) end if ! Singular values. s = abs ( s ) end procedure end submodule","tags":"","loc":"sourcefile/svd.f90~4.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_linear_solver implicit none ( type , external ) contains module procedure solve_single_rhs x = real ( ifft ( fft ( cmplx ( b , kind = dp ), A % n ) / A % c_hat , A % n )) / A % n end procedure module procedure solve_multi_rhs integer ( ilp ) :: i x = b do concurrent ( i = 1 : size ( b , 2 )) x (:, i ) = solve ( A , b (:, i )) enddo end procedure end submodule","tags":"","loc":"sourcefile/solve.f90~6.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_symtridiagonal ) symtridiagonal_linear_solver use stdlib_optval , only : optval use stdlib_linalg_lapack , only : gttrf , gttrs , gtrfs use stdlib_linalg_lapack , only : pttrf , pttrs , ptrfs use stdlib_linalg_state , only : linalg_state_type , linalg_error_handling , LINALG_ERROR , & LINALG_INTERNAL_ERROR , LINALG_VALUE_ERROR , LINALG_SUCCESS implicit none ( type , external ) character ( * ), parameter :: this = \"symtridiagonal_linear_solver\" contains module procedure solve_single_rhs ! Local variables. logical ( lk ) :: refine_ real ( dp ), pointer :: xmat (:, :), bmat (:, :) refine_ = optval ( refine , . false .) x = b ; xmat ( 1 : A % n , 1 : 1 ) => x ; bmat ( 1 : A % n , 1 : 1 ) => b if ( A % isposdef ) then xmat = posdef_symtridiagonal_solver ( A , bmat , refine_ ) else xmat = symtridiagonal_solver ( A , bmat , refine_ ) end if end procedure module procedure solve_multi_rhs ! Local variables. logical ( lk ) :: refine_ refine_ = optval ( refine , . false .) if ( A % isposdef ) then x = posdef_symtridiagonal_solver ( A , b , refine_ ) else x = symtridiagonal_solver ( A , b , refine_ ) end if end procedure !--------------------------------------------------- !-----     Generic (Sym)Tridiagonal Solver     ----- !--------------------------------------------------- ! Process GTTRF elemental subroutine handle_gttrf_info ( n , info , err ) integer ( ilp ), intent ( in ) :: n , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid problem size n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for dl.\" ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for d.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for du.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for du2.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid size for ipiv.\" ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"Singular matrix.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gttrf\" ) end select end subroutine handle_gttrf_info ! Process GTTRS elemental subroutine handle_gttrs_info ( trans , n , nrhs , ldb , info , err ) character , intent ( in ) :: trans integer ( ilp ), intent ( in ) :: n , nrhs , ldb , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for trans\" , trans ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid problem size n=\" , n ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid number of rhs nrhs=\" , nrhs ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for dl.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for d.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for du2.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for ipiv.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid dimensions for b.\" ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gttrs\" ) end select end subroutine handle_gttrs_info ! Process GTRFS elemental subroutine handle_gtrfs_info ( trans , n , nrhs , ldb , ldx , info , err ) character , intent ( in ) :: trans integer ( ilp ), intent ( in ) :: n , nrhs , ldb , ldx , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for trans=\" , trans ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for dl.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for d.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for du.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for dlf.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for df.\" ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for duf.\" ) case ( - 10 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for du2.\" ) case ( - 11 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ipiv.\" ) case ( - 12 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for b.\" ) case ( - 13 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case ( - 14 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for x.\" ) case ( - 15 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldx=\" , ldx ) case ( - 16 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ferr.\" ) case ( - 17 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for berr.\" ) case ( - 18 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for work.\" ) case ( - 19 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for iwork.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by gtrfs\" ) end select end subroutine handle_gtrfs_info function symtridiagonal_solver ( A , b , refine ) result ( x ) type ( SymTridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), intent ( in ) :: refine !! Iterative refinement of the solution? real ( dp ), allocatable :: x (:, :) !! Solution vectors. ! General LAPACK variables. integer ( ilp ) :: n , nrhs , info ! LAPACK variables for LU decomposition. real ( dp ), allocatable :: dl (:), d (:), du (:), du2 (:) integer ( ilp ), allocatable :: ipiv (:) ! LAPACK variables for iterative refinement. real ( dp ), allocatable :: ferr (:), berr (:), work (:) integer ( ilp ), allocatable :: iwork (:) ! Error handler. type ( linalg_state_type ) :: err ! Initialize data. n = A % n ; nrhs = size ( b , 2 ); x = b !------------------------------------ !-----     LU factorization     ----- !------------------------------------ ! ----- Allocations ----- allocate ( du2 ( n - 2 ), ipiv ( n )) dl = A % ev ; d = A % dv ; du = A % ev ; ! ----- LU factorization ----- call gttrf ( n , dl , d , du , du2 , ipiv , info ) call handle_gttrf_info ( n , info , err ) !------------------------------------- !-----     Tridiagonal solve     ----- !------------------------------------- ! ----- Solve the system ----- call gttrs ( \"N\" , n , nrhs , dl , d , du , du2 , ipiv , x , n , info ) call handle_gttrs_info ( \"N\" , n , nrhs , n , info , err ) !---------------------------------------- !-----     Iterative refinement     ----- !---------------------------------------- if ( refine ) then ! ----- Allocate arrays ----- allocate ( ferr ( nrhs ), berr ( nrhs ), work ( 3 * n ), iwork ( n )) ! ----- Refinement step ----- call gtrfs ( \"N\" , n , nrhs , A % ev , A % dv , A % ev , dl , d , du , du2 , ipiv , b , & n , x , n , ferr , berr , work , iwork , info ) call handle_gtrfs_info ( \"N\" , n , nrhs , n , n , info , err ) end if end function symtridiagonal_solver !----------------------------------------------------------- !-----     Positive-definite SymTridiagonal Solver     ----- !----------------------------------------------------------- ! Process PTTRF elemental subroutine handle_pttrf_info ( n , info , err ) integer ( ilp ), intent ( in ) :: n , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid matrix dimension n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( 1 :) err = linalg_state_type ( this , LINALG_ERROR , \"Matrix could not be factorized.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by pttrf\" ) end select end subroutine handle_pttrf_info ! Process PTTRS elemental subroutine handle_pttrs_info ( n , nrhs , ldb , info , err ) integer ( ilp ), intent ( in ) :: n , nrhs , ldb , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for B.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by pttrs\" ) end select end subroutine handle_pttrs_info ! Process PTRFS elemental subroutine handle_ptrfs_info ( n , nrhs , ldb , ldx , info , err ) integer ( ilp ), intent ( in ) :: n , nrhs , ldb , ldx , info type ( linalg_state_type ), intent ( inout ) :: err select case ( info ) case ( 0 ) ! Success. err % state = LINALG_SUCCESS case ( - 1 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for n=\" , n ) case ( - 2 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for nrhs=\" , nrhs ) case ( - 3 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for D.\" ) case ( - 4 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for E.\" ) case ( - 5 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for DF.\" ) case ( - 6 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for EF.\" ) case ( - 7 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for B.\" ) case ( - 8 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldb=\" , ldb ) case ( - 9 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for X.\" ) case ( - 10 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ldx=\" , ldx ) case ( - 11 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for ferr.\" ) case ( - 12 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for berr.\" ) case ( - 13 ) err = linalg_state_type ( this , LINALG_VALUE_ERROR , \"Invalid value for work.\" ) case default err = linalg_state_type ( this , LINALG_INTERNAL_ERROR , \"Unknown error returned by ptrfs\" ) end select end subroutine handle_ptrfs_info function posdef_symtridiagonal_solver ( A , b , refine ) result ( x ) type ( SymTridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), intent ( in ) :: refine !! Iterative refinement of the solution? real ( dp ), allocatable :: x (:, :) !! Solution vectors. ! General LAPACK variables. integer ( ilp ) :: n , nrhs , info ! LAPACK variables for LDL&#94;T decomposition. real ( dp ), allocatable :: dv (:), ev (:) ! LAPACK variables for iterative refinement. real ( dp ), allocatable :: ferr (:), berr (:), work (:) ! Error handler. type ( linalg_state_type ) :: err ! Initialize data. n = A % n ; nrhs = size ( b , 2 ); x = b !------------------------------------ !-----     LU factorization     ----- !------------------------------------ ! ----- Allocations ----- ev = A % ev ; dv = A % dv ! ----- LDL&#94;T factorization ----- call pttrf ( n , dv , ev , info ) call handle_pttrf_info ( n , info , err ) !------------------------------------- !-----     Tridiagonal solve     ----- !------------------------------------- ! ----- Solve the system ----- call pttrs ( n , nrhs , dv , ev , x , n , info ) call handle_pttrs_info ( n , nrhs , n , info , err ) !---------------------------------------- !-----     Iterative refinement     ----- !---------------------------------------- if ( refine ) then ! ----- Allocate arrays ----- allocate ( ferr ( nrhs ), berr ( nrhs ), work ( 2 * n )) ! ----- Refinement step ----- call ptrfs ( n , nrhs , A % dv , A % ev , dv , ev , b , n , x , n , ferr , berr , work , info ) call handle_ptrfs_info ( n , nrhs , n , n , info , err ) end if end function posdef_symtridiagonal_solver end submodule","tags":"","loc":"sourcefile/solve.f90~7.html"},{"title":"solve.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_linear_solver use stdlib_linalg , only : norm implicit none ( type , external ) contains module procedure solve_single_rhs integer ( ilp ) :: m , n !> Sanity checks. m = size ( A , 1 ) ; n = size ( A , 2 ) if ( m /= n ) error stop \"Matrix is not square.\" if ( size ( b ) /= n ) error stop \"Dimension of b is inconsistent with A.\" allocate ( x , mold = b ) !> Solve the linear system with preconditioned GMRES. x = gmres ( A , b ) end procedure module procedure solve_multi_rhs integer ( ilp ) :: i allocate ( x , mold = b ) ! do concurrent(i=1:size(b, 2)) do i = 1 , size ( b , 2 ) x (:, i ) = solve ( A , b (:, i )) enddo end procedure !-------------------------------------------- !-----     CIRCULANT PRECONDITIONER     ----- !-------------------------------------------- pure function strang_preconditioner ( T ) result ( C ) type ( Toeplitz ), intent ( in ) :: T type ( Circulant ) :: C real ( dp ), allocatable :: c_vec (:) integer ( ilp ) :: i , n , n2 !> Dimension of the matrix. n = size ( T , 1 ) ; n2 = n / 2 !> Circulant vector. allocate ( c_vec ( n )) do concurrent ( i = 1 : n2 + 1 ) c_vec ( i ) = T % vc ( i ) enddo do concurrent ( i = n2 + 2 : n ) c_vec ( i ) = T % vr ( n - i + 2 ) enddo !> Circulant matrix. C = Circulant ( c_vec ) end function !------------------------------------------- !-----     ITERATIVE SOLVER: GMRES     ----- !------------------------------------------- pure function gmres ( A , b ) result ( x ) type ( Toeplitz ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable :: x (:) !! Solution vector. !> Krylov process. integer ( ilp ), parameter :: kmax = 128 !  Dimension of the Krylov subspace. real ( dp ), allocatable :: H (:, :) !  Upper Hessenberg matrix. real ( dp ), allocatable :: V (:, :) !  Krylov basis. type ( Circulant ) :: P !  Circulant Preconditioner. !> Givens rotations. real ( dp ), allocatable :: c (:), s (:) !  Cosine and sine components. !> Miscellaneous. real ( dp ), allocatable :: e (:), y (:) !  Right-hand side and solution of the lstsq. real ( dp ), parameter :: atol = 1 0.0_dp ** ( - precision ( 1.0_dp )) !  Absolute tolerance. real ( dp ), parameter :: rtol = 1 0.0_dp ** ( - 8 ) !  Relative tolerance. real ( dp ) :: tol !  Actual tolerance. real ( dp ) :: eps , beta logical ( lk ) :: converged integer ( ilp ) :: i , k !----- Allocate and initialize working arrays ----- allocate ( x , mold = b ) ; x = 0.0_dp !  Solution vector. allocate ( H ( kmax + 1 , kmax )) ; H = 0.0_dp !  Upper Hessenberg matrix. allocate ( V ( size ( b ), kmax + 1 )) ; V = 0.0_dp !  Krylov basis. allocate ( e ( kmax + 1 )) ; e = 0.0_dp !  Lstsq right-hand side vector. allocate ( c ( kmax )) ; c = 0.0_dp !  Cosine component of the Givens rotations. allocate ( s ( kmax )) ; s = 0.0_dp !  Sine component of the Givens rotations. !> Preconditioner. P = strang_preconditioner ( A ) !> Set the tolerance. tol = atol + norm ( b , 2 ) * rtol !----- Generalized Minimum Residual Method ----- converged = . false . do while (. not . converged ) !> Initialize data. H = 0.0_dp ; V = 0.0_dp ; V (:, 1 ) = b - matmul ( A , x ) e = 0.0_dp ; e ( 1 ) = norm ( V (:, 1 ), 2 ) c = 0.0_dp ; s = 0.0_dp if ( e ( 1 ) > tol ) then V (:, 1 ) = V (:, 1 ) / e ( 1 ) else converged = . true . exit endif !> GMRES iterations. gmres_step : do k = 1 , kmax !> Generate new Krylov vector. V (:, k + 1 ) = matmul ( A , solve ( P , V (:, k ))) !> Orthogonalization step. gram_schmidt : do i = 1 , k H ( i , k ) = dot_product ( V (:, k + 1 ), V (:, i )) V (:, k + 1 ) = V (:, k + 1 ) - H ( i , k ) * V (:, i ) enddo gram_schmidt !> Twice is enough. do i = 1 , k eps = dot_product ( V (:, k + 1 ), V (:, i )) V (:, k + 1 ) = V (:, k + 1 ) - eps * V (:, i ) H ( i , k ) = H ( i , k ) + eps enddo !> Normalize Krylov vector. H ( k + 1 , k ) = norm ( V (:, k + 1 ), 2 ) if ( H ( k + 1 , k ) > atol ) V (:, k + 1 ) = V (:, k + 1 ) / H ( k + 1 , k ) !> Apply Givens rotations to the Hessenberg matrix. call apply_givens_rotation ( H (: k + 1 , k ), c (: k ), s (: k )) !> Update the right-hand side vector accordingly. e ( k + 1 ) = - s ( k ) * e ( k ) ; e ( k ) = c ( k ) * e ( k ) !> Check convergence. if ( abs ( e ( k + 1 )) < tol ) converged = . true . if ( converged ) exit gmres_step enddo gmres_step !> Solve the least-squares problem. k = min ( k , kmax ) ; y = solve_triangular ( H (: k , : k ), e (: k )) !> Update the solution. x = x + solve ( P , matmul ( V (:, : k ), y )) enddo end function !------------------------------------ !-----     GIVENS ROTATIONS     ----- !------------------------------------ pure function givens_rotation ( x ) result ( g ) real ( dp ), intent ( in ) :: x ( 2 ) !! Vector whose second component needs to be eliminated. real ( dp ) :: g ( 2 ) !! Entries of the Givens rotation matrix. g = x / norm ( x , 2 ) end function pure subroutine apply_givens_rotation ( h , c , s ) real ( dp ), intent ( inout ) :: h (:) !! k-th column of the Hessenberg matrix. real ( dp ), intent ( inout ) :: c (:) !! Cosine components of the Givens rotations. real ( dp ), intent ( inout ) :: s (:) !! Sine components of the Givens rotations. !----- Internal variables ----- integer ( ilp ) :: i , k real ( dp ) :: t , g ( 2 ) !> Size of the column. k = size ( h ) - 1 !> Apply previous Givens rotations to this new column. do i = 1 , k - 1 t = c ( i ) * h ( i ) + s ( i ) * h ( i + 1 ) h ( i + 1 ) = - s ( i ) * h ( i ) + c ( i ) * h ( i + 1 ) h ( i ) = t enddo !> Compute the sine and cosine components for the next rotation. g = givens_rotation ([ h ( k ), h ( k + 1 )]) ; c ( k ) = g ( 1 ) ; s ( k ) = g ( 2 ) !> Eliminate H(k+1, k). h ( k ) = c ( k ) * h ( k ) + s ( k ) * h ( k + 1 ) ; h ( k + 1 ) = 0.0_dp end subroutine !------------------------------------------- !-----     Upper Triangular solver     ----- !------------------------------------------- pure function solve_triangular ( A , b ) result ( x ) real ( dp ), intent ( in ) :: A (:, :) !! Matrix to invert. real ( dp ), intent ( in ) :: b (:) !! Right-hand side vector. real ( dp ), allocatable :: x (:) !! Solution vector. !----- Internal variables ------ integer ( ilp ) :: i , j , n !> Get problem's dimension. n = size ( A , 1 ) ; allocate ( x , mold = b ) ; x = 0.0_dp !> Back-substitution algorithm. x ( n ) = b ( n ) / A ( n , n ) do i = n - 1 , 1 , - 1 x ( i ) = b ( i ) - dot_product ( A ( i , i + 1 :), x ( i + 1 :)) x ( i ) = x ( i ) / A ( i , i ) enddo end function end submodule","tags":"","loc":"sourcefile/solve.f90~8.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_circulant ) circulant_svd use stdlib_sorting , only : sort , sort_index use stdlib_linalg , only : diag , hermitian implicit none ( type , external ) contains module procedure svdvals_rdp !> Analytic expression for the singular values. s = abs ( A % c_hat ) !> Sort in decreasing order. call sort ( s , reverse = . true .) end procedure module procedure svd_rdp integer ( ilp ) :: i , n integer ( ilp ), allocatable :: indices (:) complex ( dp ), allocatable :: lambda (:), left (:, :), right (:, :) complex ( dp ), allocatable :: pi (:, :), D (:, :) !> Matrix dimension. n = A % n !> Allocate variables. allocate ( lambda ( n ), left ( n , n ), right ( n , n )) !> Eigendecomposition of the Circulant matrix. call eig ( A , lambda , right = right , left = left ) ; left = hermitian ( left ) !> Singular values. s = abs ( A % c_hat ) !> Right singular vectors. vt = discrete_hartley_transform ( left ) !> Left singular vectors. pi = matmul ( transpose ( left ), left ) ; D = diag ( A % c_hat / s ) u = discrete_hartley_transform ( left ) u = matmul ( u , real ( D % re - matmul ( pi , D % im ))) !> Sort the SVD. allocate ( indices ( n )) ; call sort_index ( s , indices , reverse = . true .) u = u (:, indices ) ; vt = vt ( indices , :) end procedure pure function discrete_hartley_transform ( F ) result ( H ) complex ( dp ), intent ( in ) :: F (:, :) !! Input matrix. real ( dp ), allocatable :: H (:, :) !! Hartley transform of F. H = F % re + F % im end function end submodule","tags":"","loc":"sourcefile/svd.f90~5.html"},{"title":"svd.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_toeplitz ) toeplitz_svd implicit none ( type , external ) contains module procedure svdvals_rdp s = svdvals ( dense ( A )) end procedure module procedure svd_rdp real ( dp ), allocatable :: Amat (:, :) Amat = dense ( A ) ; call svd ( Amat , s , u , vt , overwrite_a = . true .) end procedure end submodule","tags":"","loc":"sourcefile/svd.f90~6.html"},{"title":"specialmatrices_tridiagonal.f90 – SpecialMatrices","text":"Source Code module specialmatrices_tridiagonal use stdlib_linalg_constants , only : dp , ilp , lk implicit none ( type , external ) private ! --> Linear algebra public :: transpose public :: det , trace public :: matmul public :: inv public :: solve public :: svd , svdvals public :: eig , eigvals ! --> Utility functions. public :: dense public :: shape public :: size public :: operator ( * ) !------------------------------------------------------- !-----     Base types for Tridiagonal matrices     ----- !------------------------------------------------------- type , public :: Tridiagonal !! Base type used to define a `Tridiagonal` matrix of size `[n, n]` !! with diagonals given by rank-1 arrays `dl` (size `n`), `dv` !! (size `n-1`) and `du` (size `n-1`). private integer ( ilp ) :: n !! Dimension of the matrix. real ( dp ), allocatable :: dl (:), dv (:), du (:) !! Tridiagonal elements of the matrix. end type !-------------------------------- !-----     Constructors     ----- !-------------------------------- interface Tridiagonal !! This interface provides different methods to construct a !! `Tridiagonal` matrix. Only the non-zero elements of  A  are !! stored, i.e. !! !!  !!    A !!    = !!    \\begin{bmatrix} !!       a_1   &  b_1  \\\\ !!       c_1  &  a_2      &  b_2  \\\\ !!             &  \\ddots   &  \\ddots   &  \\ddots   \\\\ !!             &           &  c_{n-2} &  a_{n-1}  &  b_{n-1} \\\\ !!             &           &           &  c_{n-1} &  a_n !!    \\end{bmatrix}. !!  !! !! #### Syntax !! !! - Construct a `Tridiagonal` matrix filled with zeros: !! !! ```fortran !!    integer, parameter :: n = 100 !!    type(Tridiagonal) :: A !! !!    A = Tridiagonal(n) !! ``` !! !! - Construct a `Tridiagonal` matrix from rank-1 arrays: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), allocatable :: dl(:), dv(:), du(:) !!    type(Tridiagonal) :: A !!    integer :: i !! !!    dl = [(i, i=1, n-1)]; dv = [(2*i, i=1, n)]; du = [(3*i, i=1, n)] !!    A = Tridiagonal(dl, dv, du) !! ``` !! !! - Construct a `Tridiagonal` matrix with constant diagonals: !! !! ```fortran !!    integer, parameter :: n !!    real(dp), parameter :: a = 1.0_dp, b = 1.0_dp, c = 2.0_dp !!    type(Tridiagonal) :: A !! !!    A = Tridiagonal(a, b, c, n) !! ``` !! !! @note !! Only `double precision` is currently supported for this matrix type. !! @endnote pure module function initialize ( n ) result ( A ) !! Construct a `Tridiagonal` matrix filled with zeros. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Tridiagonal ) :: A !! Tridiagonal matrix. end function pure module function construct ( dl , dv , du ) result ( A ) !! Construct a `Tridiagonal` matrix from the rank-1 arrays `dl`, !! `dv` and `du`. real ( dp ), intent ( in ) :: dl (:), dv (:), du (:) !! Tridiagonal elements of the matrix. type ( Tridiagonal ) :: A !! Tridiagonal matrix. end function pure module function construct_constant ( dl , dv , du , n ) result ( A ) !! Construct a `Tridiagonal` matrix with constant diagonal elements. real ( dp ), intent ( in ) :: dl , dv , du !! Tridiagonal elements of the matrix. integer ( ilp ), intent ( in ) :: n !! Dimension of the matrix. type ( Tridiagonal ) :: A !! Tridiagonal matrix. end function end interface !------------------------------------------------------------------- !-----     Matrix-vector and Matrix-matrix multiplications     ----- !------------------------------------------------------------------- interface matmul !! This interface overloads the Fortran intrinsic `matmul` for a !! `Tridiagonal` matrix, both for matrix-vector and matrix-matrix !! products. For a matrix-matrix product  C = AB , only the matrix !!  A  has to be a `Tridiagonal` matrix. Both  B  and  C  !! need to be standard Fortran rank-2 arrays. All the underlying !! functions are defined as `pure`. !! !! #### Syntax !! !! ```fortran !!    y = matmul(A, x) !! ``` module function spmv ( A , x ) result ( y ) !! Compute the matrix-vector product y = Ax for a `Tridiagonal` !! matrix A. Both `x` and `y` are rank-1 arrays with the same !! kind as `A`. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), target , intent ( in ) :: x (:) !! Input vector. real ( dp ), target , allocatable :: y (:) !! Output vector. end function pure module function spmvs ( A , x ) result ( y ) !! Compute the matrix-matrix product Y = Ax for a `Tridiagonal` !! matrix A and a dense matrix X (rank-2 array). Y is !! also a rank-2 array with the same dimensions as X. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( in ) :: X (:, :) !! Input vectors. real ( dp ), allocatable :: Y (:, :) !! Output vectors. end function end interface !----------------------------------------------- !-----     Linear systems of equations     ----- !----------------------------------------------- interface solve !! This interface overloads the `solve` interface from `stdlib_linalg` !! for solving a linear system  Ax = b  where  A  is a !! `Tridiagonal` matrix. It also enables to solve a linear system with !! multiple right-hand sides. !! !! #### Syntax !! !! ```fortran !!    x = solve(A, b [, refine]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `b` :  Rank-1 or rank-2 array defining the right-hand side(s). !!          It is an `intent(in)` argument. !! !! - `refine` (optional) : Logical switch to enable solution refinement. !!                         It is an `intent(in)` argument. !! !! - `x` :  Solution of the linear system. !!          It has the same type and shape as `b`. module function solve_single_rhs ( A , b , refine ) result ( x ) !! Solve the linear system Ax=b where A is of type !! `Tridiagonal` and `b` a standard rank-1 array. The solution !! vector `x` has the same dimension and kind as `b`. type ( Tridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ), target :: b (:) !! Right-hand side vector. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refinement is used or not. real ( dp ), allocatable , target :: x (:) !! Solution vector. end function module function solve_multi_rhs ( A , b , refine ) result ( x ) !! Solve the linear system AX=B where A is of type !! `Tridiagonal` and `B` a standard rank-2 array. The solution !! matrix `X` has the same dimensions and kind as `B`. type ( Tridiagonal ), intent ( in ) :: A !! Coefficient matrix. real ( dp ), intent ( in ) :: b (:, :) !! Right-hand side vectors. logical ( lk ), optional , intent ( in ) :: refine !! Whether iterative refined is used or not. real ( dp ), allocatable , target :: x (:, :) !! Solution vectors. end function end interface interface inv pure module function inv_rdp ( A ) result ( B ) !! Compute the inverse of a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: B (:, :) !! Inverse of `A`. end function end interface !----------------------------------------- !-----     Determinant and Trace     ----- !----------------------------------------- interface det !! This interface overloads the `det` interface from `stdlib_linag` to !! compute the determinant \\det(A) where A is of type !! `Tridiagonal`. !! !! #### Syntax !! !! ```fortran !!    d = det(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is in an `intent(in)` argument. !! !! - `d` :  Determinant of the matrix. pure module function det_rdp ( A ) result ( d ) !! Compute the determinant of a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: d !! Determinant of the matrix. end function end interface interface trace !! This interface overloads the `trace` interface from `stdlib_linalg` !! to compute the trace of a matrix  A  of type `Tridiagonal`. !! !! #### Syntax !! !! ```fortran !!    tr = trace(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `tr`:  Trace of the matrix. pure module function trace_rdp ( A ) result ( tr ) !! Compute the trace of a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ) :: tr !! Trace of the matrix. end function end interface !------------------------------------------------ !-----     Singular Value Decomposition     ----- !------------------------------------------------ interface svdvals !! This interface overloads the `svdvals` interface from !! `stdlib_linalg` to compute the singular values of a `Tridiagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    s = svdvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Vector of singular values sorted in decreasing order. module function svdvals_rdp ( A ) result ( s ) !! Compute the singular values of a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), allocatable :: s (:) !! Singular values in descending order. end function end interface interface svd !! This interface overloads the `svd` interface from `stdlib_linalg` !! to compute the the singular value decomposition of a `Tridiagonal` !! matrix A. !! !! #### Syntax !! !! ```fortran !!    call svd(A, s [, u] [, vt]) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `s` :  Rank-1 array `real` array returning the singular values of !!          `A`. It is an `intent(out)` argument. !! !! - `u` (optional)  :  Rank-2 array of the same kind as `A` returning !!                      the left singular vectors of `A` as columns. !!                       Its size should be `[n, n]`. !!                      It is an `intent(out)` argument. !! !! - `vt` (optional) :  Rank-2 array of the same kind as `A` returning !!                      the right singular vectors of `A` as rows. Its !!                      size should be `[n, n]`. !!                      It is an `intent(out)` argument. module subroutine svd_rdp ( A , s , u , vt ) !! Compute the singular value decomposition of a `Tridiagonal` !! matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. real ( dp ), intent ( out ) :: s (:) !! Singular values in descending order. real ( dp ), optional , intent ( out ) :: u (:, :) !! Left singular vectors as columns. real ( dp ), optional , intent ( out ) :: vt (:, :) !! Right singular vectors as rows. end subroutine end interface !-------------------------------------------- !-----     Eigenvalue Decomposition     ----- !-------------------------------------------- interface eigvals !! This interface overloads the `eigvals` interface from !! `stdlib_linalg` to compute the eigenvalues of a real-valued matrix !!  A  whose type is `Tridiagonal`. !! !! #### Syntax !! !! ```fortran !!    lambda = eigvals(A) !! ``` !! !! #### Arguments !! !! - `A` :  `real`-valued matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `lambda` :  Vector of eigenvalues in increasing order. module function eigvals_rdp ( A ) result ( lambda ) !! Utility function to compute the eigenvalues of a real !! `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. complex ( dp ), allocatable :: lambda (:) !! Eigenvalues. end function end interface interface eig !! This interface overloads the `eig` interface from `stdlib_linalg` !! to compute the eigenvalues and eigenvectors of a real-valued matrix !! A whose type is `Tridiagonal`. !! !! #### Syntax !! !! ```fortran !!    call eig(A, lambda [, left] [, right]) !! ``` !! !! #### Arguments !! !! - `A` : `real`-valued matrix of `Tridiagonal`. !!          It is an `intent(in)` argument. !! !! - `lambda`  :  Rank-1 `real` array returning the eigenvalues of `A` !!                in increasing order. It is an `intent(out)` argument. !! !! - `left` (optional)  :  `complex` rank-2 array of the same kind as !!                         `A` returning the left eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! - `right` (optional) :  `complex` rank-2 array of the same kind as !!                         `A` returning the right eigenvectors of `A`. !!                         It is an `intent(out)` argument. !! !! @note !! No specialized eigensolvers for generic `Tridiagonal` matrices exist !! in LAPACK. This routine thus falls back to wrapping the `eig` !! procedure from `stdlib_linalg` which uses `*geev` under the hood. !! @endnote module subroutine eig_rdp ( A , lambda , left , right ) !! Utility function to compute the eigenvalues and eigenvectors of !! a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. complex ( dp ), intent ( out ) :: lambda (:) !! Eigenvalues. complex ( dp ), optional , intent ( out ) :: right (:, :), left (:, :) !! Eigenvectors. end subroutine end interface !------------------------------------- !-----     Utility functions     ----- !------------------------------------- interface dense !! This interface provides methods to convert a `Tridiagonal` matrix !! to a regular rank-2 array. !! !! #### Syntax !! !! ```fortran !!    B = dense(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Rank-2 array representation of the matrix  A . module function dense_rdp ( A ) result ( B ) !! Utility function to convert a `Tridiagonal` matrix to a rank-2 !! array. type ( Tridiagonal ), intent ( in ) :: A !! Input diagonal matrix. real ( dp ), allocatable :: B (:, :) !! Output dense rank-2 array. end function end interface interface transpose !! This interface overloads the Fortran `intrinsic` procedure to define !! the transpose operation for a `Tridiagonal` matrix. !! !! #### Syntax !! !! ```fortran !!    B = transpose(A) !! ``` !! !! #### Arguments !! !! - `A` :  Matrix of `Tridiagonal` type. !!          It is an `intent(in)` argument. !! !! - `B` :  Resulting transposed matrix. It is of the same type as `A`. pure module function transpose_rdp ( A ) result ( B ) !! Utility function to compute the transpose of a `Tridiagonal` !! matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. type ( Tridiagonal ) :: B !! Transpose of the matrix. end function end interface interface size pure module function size_rdp ( A , dim ) result ( arr_size ) !! Return the size of `Tridiagonal` matrix along a given dimension. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ), optional , intent ( in ) :: dim !! Queried dimension. integer ( ilp ) :: arr_size !! Size of the matrix along the dimension dim. end function end interface interface shape pure module function shape_rdp ( A ) result ( arr_shape ) !! Return the shape of a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A !! Input matrix. integer ( ilp ) :: arr_shape ( 2 ) !! Shape of the matrix. end function end interface interface operator ( * ) pure module function scalar_multiplication_rdp ( alpha , A ) result ( B ) !! Scalar multiplication with a `Tridiagonal` matrix. real ( dp ), intent ( in ) :: alpha type ( Tridiagonal ), intent ( in ) :: A type ( Tridiagonal ) :: B end function scalar_multiplication_rdp pure module function scalar_multiplication_bis_rdp ( A , alpha ) result ( B ) !! Scalar multiplication with a `Tridiagonal` matrix. type ( Tridiagonal ), intent ( in ) :: A real ( dp ), intent ( in ) :: alpha type ( Tridiagonal ) :: B end function scalar_multiplication_bis_rdp end interface end module","tags":"","loc":"sourcefile/specialmatrices_tridiagonal.f90.html"},{"title":"matvecs.f90 – SpecialMatrices","text":"Source Code submodule ( specialmatrices_poisson2D ) poisson2D_matvecs implicit none ( type , external ) contains module procedure spmv real ( dp ), pointer , contiguous :: xmat (:, :), ymat (:, :) real ( dp ) :: dx , dy , d2x , d2y integer ( ilp ) :: i , j , nx , ny ! Initialize arrays and pointers. nx = A % nx ; ny = A % ny ; dx = A % dx ; dy = A % dy y = x ; ymat ( 1 : nx , 1 : ny ) => y ; xmat ( 1 : nx , 1 : ny ) => x ! Evaluate the Laplace operator. do concurrent ( i = 1 : nx , j = 1 : ny ) ! Horizontl contribution. if ( i == 1 ) then d2x = ( - 2 * xmat ( i , j ) + xmat ( i + 1 , j )) / dx ** 2 else if ( i == nx ) then d2x = ( xmat ( i - 1 , j ) - 2 * xmat ( i , j )) / dx ** 2 else d2x = ( xmat ( i - 1 , j ) - 2 * xmat ( i , j ) + xmat ( i + 1 , j )) / dx ** 2 endif ! Vertical contribution. if ( j == 1 ) then d2y = ( - 2 * xmat ( i , j ) + xmat ( i , j + 1 )) / dy ** 2 else if ( j == ny ) then d2y = ( xmat ( i , j - 1 ) - 2 * xmat ( i , j )) / dy ** 2 else d2y = ( xmat ( i , j - 1 ) - 2 * xmat ( i , j ) + xmat ( i , j + 1 )) / dy ** 2 endif ! Laplacien. ymat ( i , j ) = d2x + d2y enddo end procedure module procedure spmvs real ( dp ), pointer , contiguous :: ymat (:, :, :), xmat (:, :, :) real ( dp ) :: dx , dy , d2x , d2y integer ( ilp ) :: i , j , k , nx , ny , nrhs ! Initialize arrays and pointers. nx = A % nx ; ny = A % ny ; dx = A % dx ; dy = A % dy ; nrhs = size ( x , 2 ) y = x ; ymat ( 1 : nx , 1 : ny , 1 : nrhs ) => y ; xmat ( 1 : nx , 1 : ny , 1 : nrhs ) => x ! Evaluate the Laplace operator. do concurrent ( i = 1 : nx , j = 1 : ny , k = 1 : nrhs ) ! Horizontl contribution. if ( i == 1 ) then d2x = ( - 2 * xmat ( i , j , k ) + xmat ( i + 1 , j , k )) / dx ** 2 else if ( i == nx ) then d2x = ( xmat ( i - 1 , j , k ) - 2 * xmat ( i , j , k )) / dx ** 2 else d2x = ( xmat ( i - 1 , j , k ) - 2 * xmat ( i , j , k ) + xmat ( i + 1 , j , k )) / dx ** 2 endif ! Vertical contribution. if ( j == 1 ) then d2y = ( - 2 * xmat ( i , j , k ) + xmat ( i , j + 1 , k )) / dy ** 2 else if ( j == ny ) then d2y = ( xmat ( i , j - 1 , k ) - 2 * xmat ( i , j , k )) / dy ** 2 else d2y = ( xmat ( i , j - 1 , k ) - 2 * xmat ( i , j , k ) + xmat ( i , j + 1 , k )) / dy ** 2 endif ! Laplacien. ymat ( i , j , k ) = d2x + d2y enddo end procedure end submodule","tags":"","loc":"sourcefile/matvecs.f90~8.html"}]}